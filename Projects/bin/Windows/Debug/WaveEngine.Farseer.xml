<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WaveEngine.Farseer</name>
    </assembly>
    <members>
        <member name="T:FarseerPhysics.Collision.ContactFeature">
            <summary>
            The features that intersect to form the contact point
            This must be 4 bytes or less.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.IndexA">
            <summary>
            Feature index on ShapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.IndexB">
            <summary>
            Feature index on ShapeB
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.TypeA">
            <summary>
            The feature type on ShapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.TypeB">
            <summary>
            The feature type on ShapeB
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ContactID">
            <summary>
            Contact ids to facilitate warm starting.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactID.Features">
            <summary>
            The features that intersect to form the contact point
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactID.Key">
            <summary>
            Used to quickly compare contact ids.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ManifoldPoint">
            <summary>
            A manifold point is a contact point belonging to a contact
            manifold. It holds details related to the geometry and dynamics
            of the contact points.
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleB
            -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
            -SeparationFunction.FaceB: the clip point of polygonA
            This structure is stored across time steps, so we keep it small.
            Note: the impulses are used for internal caching and may not
            provide reliable contact forces, especially for high speed collisions.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ManifoldPoint.Id">
            <summary>
            Uniquely identifies a contact point between two Shapes
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Manifold">
            <summary>
            A manifold for two touching convex Shapes.
            Box2D supports multiple types of contact:
            - clip point versus plane with radius
            - point versus point with radius (circles)
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleA
            -SeparationFunction.FaceA: the center of faceA
            -SeparationFunction.FaceB: the center of faceB
            Similarly the local normal usage:
            -ShapeType.Circles: not used
            -SeparationFunction.FaceA: the normal on polygonA
            -SeparationFunction.FaceB: the normal on polygonB
            We store contacts in this way so that position correction can
            account for movement, which is critical for continuous physics.
            All contact scenarios must be expressed in one of these types.
            This structure is stored across time steps, so we keep it small.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.LocalNormal">
            <summary>
            Not use for Type.SeparationFunction.Points
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.LocalPoint">
            <summary>
            Usage depends on manifold type
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.PointCount">
            <summary>
            The number of manifold points
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.Points">
            <summary>
            The points of contact
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.PointState">
            <summary>
            This is used for determining the state of contact points.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Null">
            <summary>
            Point does not exist
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Add">
            <summary>
            Point was added in the update
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Persist">
            <summary>
            Point persisted across the update
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Remove">
            <summary>
            Point was removed in the update
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ClipVertex">
            <summary>
            Used for computing contact manifolds.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.RayCastInput">
            <summary>
            Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.RayCastOutput">
            <summary>
            Ray-cast output data.  The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
            come from RayCastInput. 
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.AABB">
            <summary>
            An axis aligned bounding box.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.AABB.LowerBound">
            <summary>
            The lower vertex
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.AABB.UpperBound">
            <summary>
            The upper vertex
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Center">
            <summary>
            Get the center of the AABB.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Extents">
            <summary>
            Get the extents of the AABB (half-widths).
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Perimeter">
            <summary>
            Get the perimeter length
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Vertices">
            <summary>
            Gets the vertices of the AABB.
            </summary>
            <value>The corners of the AABB</value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Q1">
            <summary>
            first quadrant
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.IsValid">
            <summary>
            Verify that the bounds are sorted.
            </summary>
            <returns>
            	<c>true</c> if this instance is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@)">
            <summary>
            Combine an AABB into this one.
            </summary>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@,FarseerPhysics.Collision.AABB@)">
            <summary>
            Combine two AABBs into this one.
            </summary>
            <param name="aabb1">The aabb1.</param>
            <param name="aabb2">The aabb2.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Contains(FarseerPhysics.Collision.AABB@)">
            <summary>
            Does this aabb contain the provided AABB.
            </summary>
            <param name="aabb">The aabb.</param>
            <returns>
            	<c>true</c> if it contains the specified aabb; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Contains(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Determines whether the AAABB contains the specified point.
            </summary>
            <param name="point">The point.</param>
            <returns>
            	<c>true</c> if it contains the specified point; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FarseerPhysics.Collision.FatEdge">
            <summary>
            Edge shape plus more stuff.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.EPProxy">
            <summary>
            This lets us treate and edge shape and a polygon in the same
            way in the SAT collider.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.GetWorldManifold(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Common.Transform@,System.Single,FarseerPhysics.Common.Transform@,System.Single,WaveEngine.Common.Math.Vector2@,FarseerPhysics.Common.FixedArray2{WaveEngine.Common.Math.Vector2}@)">
            <summary>
            Evaluate the manifold with supplied transforms. This assumes
            modest motion from the original state. This does not change the
            point count, impulses, etc. The radii must come from the Shapes
            that generated the manifold.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="transformA">The transform for A.</param>
            <param name="radiusA">The radius for A.</param>
            <param name="transformB">The transform for B.</param>
            <param name="radiusB">The radius for B.</param>
            <param name="normal">World vector pointing from A to B</param>
            <param name="points">Torld contact point (point of intersection).</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollideCircles(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            Compute the collision manifold between two circles.
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollidePolygonAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute the collision manifold between a polygon and a circle.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polygonA">The polygon A.</param>
            <param name="transformA">The transform of A.</param>
            <param name="circleB">The circle B.</param>
            <param name="transformB">The transform of B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollidePolygons(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute the collision manifold between two polygons.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polyA">The poly A.</param>
            <param name="transformA">The transform A.</param>
            <param name="polyB">The poly B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute contact points for edge versus circle.
            This accounts for edge connectivity.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="transformA">The transform A.</param>
            <param name="circleB">The circle B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Collides and edge and a polygon, taking into account edge adjacency.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="xfA">The xf A.</param>
            <param name="polygonB">The polygon B.</param>
            <param name="xfB">The xf B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.ClipSegmentToLine(FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,WaveEngine.Common.Math.Vector2,System.Single,System.Int32)">
            <summary>
            Clipping for contact manifolds.
            </summary>
            <param name="vOut">The v out.</param>
            <param name="vIn">The v in.</param>
            <param name="normal">The normal.</param>
            <param name="offset">The offset.</param>
            <param name="vertexIndexA">The vertex index A.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.EdgeSeparation(FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,System.Int32,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Find the separation between poly1 and poly2 for a give edge normal on poly1.
            </summary>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="edge1">The edge1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.FindMaxSeparation(System.Int32@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Find the max separation between poly1 and poly2 using edge normals from poly1.
            </summary>
            <param name="edgeIndex">Index of the edge.</param>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceProxy">
            <summary>
            A distance proxy is used by the GJK algorithm.
            It encapsulates any shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.Set(FarseerPhysics.Collision.Shapes.Shape,System.Int32)">
            <summary>
            Initialize the proxy using the given shape. The shape
            must remain in scope while the proxy is in use.
            </summary>
            <param name="shape">The shape.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupport(WaveEngine.Common.Math.Vector2)">
            <summary>
            Get the supporting vertex index in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupportVertex(WaveEngine.Common.Math.Vector2)">
            <summary>
            Get the supporting vertex in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Collision.SimplexCache">
            <summary>
            Used to warm start ComputeDistance.
            Set count to zero on first call.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.Count">
            <summary>
            Length or area
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.IndexA">
            <summary>
            Vertices on shape A
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.IndexB">
            <summary>
            Vertices on shape B
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceInput">
            <summary>
            Input for ComputeDistance.
            You have to option to use the shape radii
            in the computation. 
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceOutput">
            <summary>
            Output for ComputeDistance.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.Iterations">
            <summary>
            Number of GJK iterations used
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.PointA">
            <summary>
            Closest point on shapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.PointB">
            <summary>
            Closest point on shapeB
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.A">
            <summary>
            Barycentric coordinate for closest point 
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexA">
            <summary>
            wA index
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexB">
            <summary>
            wB index
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.W">
            <summary>
            wB - wA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.WA">
            <summary>
            Support point in proxyA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.WB">
            <summary>
            Support point in proxyB
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DynamicTreeNode`1">
            <summary>
            A node in the dynamic tree. The client does not interact with this directly.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DynamicTreeNode`1.AABB">
            <summary>
            This is the fattened AABB.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DynamicTree`1">
             <summary>
             A dynamic tree arranges data in a binary tree to accelerate
             queries such as volume queries and ray casts. Leafs are proxies
             with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
             so that the proxy AABB is bigger than the client object. This allows the client
             object to move by small amounts without triggering a tree update.
            
             Nodes are pooled and relocatable, so we use node indices rather than pointers.
             </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DynamicTree`1._path">
            <summary>
            This is used incrementally traverse the tree for re-balancing.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.#ctor">
            <summary>
            Constructing the tree initializes the node pool.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.AddProxy(FarseerPhysics.Collision.AABB@,`0)">
            <summary>
            Create a proxy in the tree as a leaf node. We return the index
            of the node instead of a pointer so that we can grow
            the node pool.        
            /// </summary>
            <param name="aabb">The aabb.</param>
            <param name="userData">The user data.</param>
            <returns>Index of the created proxy</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.RemoveProxy(System.Int32)">
            <summary>
            Destroy a proxy. This asserts if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.MoveProxy(System.Int32,FarseerPhysics.Collision.AABB@,WaveEngine.Common.Math.Vector2)">
            <summary>
            Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
            then the proxy is removed from the tree and re-inserted. Otherwise
            the function returns immediately.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
            <param name="displacement">The displacement.</param>
            <returns>true if the proxy was re-inserted.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.Rebalance(System.Int32)">
            <summary>
            Perform some iterations to re-balance the tree.
            </summary>
            <param name="iterations">The iterations.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.GetUserData(System.Int32)">
            <summary>
            Get proxy user data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proxyId">The proxy id.</param>
            <returns>the proxy user data or 0 if the id is invalid.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
            <summary>
            Get the fat AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="fatAABB">The fat AABB.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.ComputeHeight">
            <summary>
            Compute the height of the binary tree in O(N) time. Should not be
            called often.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.RayCast(System.Func{FarseerPhysics.Collision.RayCastInput,System.Int32,System.Single},FarseerPhysics.Collision.RayCastInput@)">
            <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a Shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="T:FarseerPhysics.Collision.DynamicTreeBroadPhase">
            <summary>
            The broad-phase is used for computing pairs and performing volume queries and ray casts.
            This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
            It is up to the client to consume the new pairs and to track subsequent overlap.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTreeBroadPhase.ProxyCount">
            <summary>
            Get the number of proxies.
            </summary>
            <value>The proxy count.</value>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.AddProxy(FarseerPhysics.Dynamics.FixtureProxy@)">
            <summary>
            Create a proxy with an initial AABB. Pairs are not reported until
            UpdatePairs is called.
            </summary>
            <param name="aabb">The aabb.</param>
            <param name="proxy">The user data.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.RemoveProxy(System.Int32)">
            <summary>
            Destroy a proxy. It is up to the client to remove any pairs.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
            <summary>
            Get the AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.GetProxy(System.Int32)">
            <summary>
            Get user data from a proxy. Returns null if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.TestOverlap(System.Int32,System.Int32)">
            <summary>
            Test overlap of fat AABBs.
            </summary>
            <param name="proxyIdA">The proxy id A.</param>
            <param name="proxyIdB">The proxy id B.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.UpdatePairs(FarseerPhysics.Dynamics.BroadphaseDelegate)">
            <summary>
            Update the pairs. This results in pair callbacks. This can only add pairs.
            </summary>
            <param name="callback">The callback.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.RayCast(System.Func{FarseerPhysics.Collision.RayCastInput,System.Int32,System.Single},FarseerPhysics.Collision.RayCastInput@)">
            <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.ComputeHeight">
            <summary>
            Compute the height of the embedded tree.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.TestPoint(FarseerPhysics.Common.Transform@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.ComputeProperties">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.EdgeShape">
            <summary>
            A line segment (edge) Shape. These can be connected in chains or loops
            to other edge Shapes. The connectivity information is used to ensure
            correct contact normals.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex0">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex3">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape._vertex1">
            <summary>
            Edge start vertex
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape._vertex2">
            <summary>
            Edge end vertex
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex1">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex2">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.Set(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Set this as an isolated edge.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.TestPoint(FarseerPhysics.Common.Transform@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.ComputeProperties">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.LoopShape">
            <summary>
            A loop Shape is a free form sequence of line segments that form a circular list.
            The loop may cross upon itself, but this is not recommended for smooth collision.
            The loop has double sided collision, so you can use inside and outside collision.
            Therefore, you may use any winding order.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.LoopShape.Vertices">
            <summary>
            The vertices. These are not owned/freed by the loop Shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.GetChildEdge(FarseerPhysics.Collision.Shapes.EdgeShape@,System.Int32)">
            <summary>
            Get a child edge.
            </summary>
            <param name="edge">The edge.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.TestPoint(FarseerPhysics.Common.Transform@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.ComputeProperties">
            <summary>
            Chains have zero mass.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.PolygonShape">
            <summary>
            Represents a simple non-selfintersecting convex polygon.
            If you want to have concave polygons, you will have to use the <see cref="T:FarseerPhysics.Common.Decomposition.BayazitDecomposer"/> or the <see cref="T:FarseerPhysics.Common.Decomposition.EarclipDecomposer"/>
            to decompose the concave polygon into 2 or more convex polygons.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.#ctor(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Collision.Shapes.PolygonShape"/> class.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="density">The density.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.Set(FarseerPhysics.Common.Vertices)">
            <summary>
            Copy vertices. This assumes the vertices define a convex polygon.
            It is assumed that the exterior is the the right of each edge.
            </summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.ComputeProperties">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single)">
            <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
            <param name="halfWidth">The half-width.</param>
            <param name="halfHeight">The half-height.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single,WaveEngine.Common.Math.Vector2,System.Single)">
            <summary>
            Build vertices to represent an oriented box.
            </summary>
            <param name="halfWidth">The half-width..</param>
            <param name="halfHeight">The half-height.</param>
            <param name="center">The center of the box in local coordinates.</param>
            <param name="angle">The rotation of the box in local coordinates.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.TestPoint(FarseerPhysics.Common.Transform@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.MassData">
            <summary>
            This holds the mass data computed for a shape.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.MassData.Area">
            <summary>
            The area of the shape
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.MassData.Centroid">
            <summary>
            The position of the shape's centroid relative to the shape's origin.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.MassData.Inertia">
            <summary>
            The rotational inertia of the shape about the local origin.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.MassData.Mass">
            <summary>
            The mass of the shape, usually in kilograms.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.Shape">
            <summary>
            A shape is used for collision detection. You can create a shape however you like.
            Shapes used for simulation in World are created automatically when a Fixture
            is created. Shapes may encapsulate a one or more child shapes.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.ShapeType">
            <summary>
            Get the type of this shape.
            </summary>
            <value>The type of the shape.</value>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.ChildCount">
            <summary>
            Get the number of child primitives.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.Density">
            <summary>
            Gets or sets the density.
            </summary>
            <value>The density.</value>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.Radius">
            <summary>
            Radius of the Shape
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.Clone">
            <summary>
            Clone the concrete shape
            </summary>
            <returns>A clone of the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.TestPoint(FarseerPhysics.Common.Transform@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeProperties">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.TOIInput">
            <summary>
            Input parameters for CalculateTimeOfImpact
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.TimeOfImpact.CalculateTimeOfImpact(FarseerPhysics.Collision.TOIOutput@,FarseerPhysics.Collision.TOIInput)">
            <summary>
            Compute the upper bound on time before two shapes penetrate. Time is represented as
            a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
            non-tunneling collision. If you change the time interval, you should call this function
            again.
            Note: use Distance() to compute the contact point and normal at the time of impact.
            </summary>
            <param name="output">The output.</param>
            <param name="input">The input.</param>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.ChainHull.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Gets the convex hull.
            </summary>
            <remarks>
            http://www.softsurfer.com/Archive/algorithm_0109/algorithm_0109.htm
            </remarks>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.GiftWrap.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Find the convex hull of a point cloud using "Gift-wrap" algorithm - start
            with an extremal point, and walk around the outside edge by testing
            angles.
            
            Runs in O(N*S) time where S is number of sides of resulting polygon.
            Worst case: point cloud is all vertices of convex polygon: O(N^2).
            There may be faster algorithms to do this, should you need one -
            this is just the simplest. You can get O(N log N) expected time if you
            try, I think, and O(N) if you restrict inputs to simple polygons.
            Returns null if number of vertices passed is less than 3.
            Results should be passed through convex decomposition afterwards
            to ensure that each shape has few enough points to be used in Box2d.
            
            Warning: May be buggy with colinear points on hull.
            </summary>
            <param name="vertices">The vertices.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.Melkman.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Creates a convex hull.
            Note:
            1. Vertices must be of a simple polygon, i.e. edges do not overlap.
            2. Melkman does not work on point clouds
            </summary>
            <remarks>
            Implemented using Melkman's Convex Hull Algorithm - O(n) time complexity.
            Reference: http://www.ams.sunysb.edu/~jsbm/courses/345/melkman.pdf
            </remarks>
            <returns>A convex hull in counterclockwise winding order.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.BayazitDecomposer">
            <summary>
            Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
            For more information about this algorithm, see http://mnbayazit.com/406/bayazit
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            If the polygon is already convex, it will return the original polygon, unless it is over Settings.MaxPolygonVertices.
            Precondition: Counter Clockwise polygon
            </summary>
            <param name="vertices"></param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.EarclipDecomposer">
            <summary>
            Ported from jBox2D. Original author: ewjordan 
            Triangulates a polygon using simple ear-clipping algorithm.
            
            Only works on simple polygons.
            
            Triangles may be degenerate, especially if you have identical points
            in the input to the algorithm.  Check this before you use them.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
             <summary>
             Decomposes a non-convex polygon into a number of convex polygons, up
             to maxPolys (remaining pieces are thrown out).
            
             Each resulting polygon will have no more than Settings.MaxPolygonVertices
             vertices.
             
             Warning: Only works on simple polygons
             </summary>
             <param name="vertices">The vertices.</param>
             <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices,System.Int32,System.Single)">
            <summary>
            Decomposes a non-convex polygon into a number of convex polygons, up
            to maxPolys (remaining pieces are thrown out).
            Each resulting polygon will have no more than Settings.MaxPolygonVertices
            vertices.
            Warning: Only works on simple polygons
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="maxPolys">The maximum number of polygons.</param>
            <param name="tolerance">The tolerance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.PolygonizeTriangles(System.Collections.Generic.List{FarseerPhysics.Common.Decomposition.Triangle},System.Int32,System.Single)">
             <summary>
             Turns a list of triangles into a list of convex polygons. Very simple
             method - start with a seed triangle, keep adding triangles to it until
             you can't add any more without making the polygon non-convex.
            
             Returns an integer telling how many polygons were created.  Will fill
             polys array up to polysLength entries, which may be smaller or larger
             than the return value.
             
             Takes O(N///P) where P is the number of resultant polygons, N is triangle
             count.
             
             The final polygon list will not necessarily be minimal, though in
             practice it works fairly well.
             </summary>
             <param name="triangulated">The triangulated.</param>
            <param name="maxPolys">The maximun number of polygons</param>
            <param name="tolerance">The tolerance</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(FarseerPhysics.Common.Vertices)">
             <summary>
             Triangulates a polygon using simple ear-clipping algorithm. Returns
             size of Triangle array unless the polygon can't be triangulated.
             This should only happen if the polygon self-intersects,
             though it will not _always_ return null for a bad polygon - it is the
             caller's responsibility to check for self-intersection, and if it
             doesn't, it should at least check that the return value is non-null
             before using. You're warned!
            
             Triangles may be degenerate, especially if you have identical points
             in the input to the algorithm.  Check this before you use them.
            
             This is totally unoptimized, so for large polygons it should not be part
             of the simulation loop.
            
             Warning: Only works on simple polygons.
             </summary>
             <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ResolvePinchPoint(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Finds and fixes "pinch points," points where two polygon
            vertices are at the same point.
            
            If a pinch point is found, pin is broken up into poutA and poutB
            and true is returned; otherwise, returns false.
            
            Mostly for internal use.
            
            O(N^2) time, which sucks...
            </summary>
            <param name="pin">The pin.</param>
            <param name="poutA">The pout A.</param>
            <param name="poutB">The pout B.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(System.Int32,System.Int32)">
            <summary>
            Fix for obnoxious behavior for the % operator for negative numbers...
            </summary>
            <param name="x">The x.</param>
            <param name="modulus">The modulus.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.IsEar(System.Int32,System.Single[],System.Single[],System.Int32)">
             <summary>
             Checks if vertex i is the tip of an ear in polygon defined by xv[] and
             yv[].
            
             Assumes clockwise orientation of polygon...ick
             </summary>
             <param name="i">The i.</param>
             <param name="xv">The xv.</param>
             <param name="yv">The yv.</param>
             <param name="xvLength">Length of the xv.</param>
             <returns>
             	<c>true</c> if the specified i is ear; otherwise, <c>false</c>.
             </returns>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer">
            <summary>
            Triangulates a polygon into triangles.
            Doesn't handle holes.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.InsideTriangle(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Check if the point P is inside the triangle defined by
            the points A, B, C
            </summary>
            <param name="a">The A point.</param>
            <param name="b">The B point.</param>
            <param name="c">The C point.</param>
            <param name="p">The point to be tested.</param>
            <returns>True if the point is inside the triangle</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.Snip(FarseerPhysics.Common.Vertices,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
            Cut a the contour and add a triangle into V to describe the 
            location of the cut
            </summary>
            <param name="contour">The list of points defining the polygon</param>
            <param name="u">The index of the first point</param>
            <param name="v">The index of the second point</param>
            <param name="w">The index of the third point</param>
            <param name="n">The number of elements in the array.</param>
            <param name="V">The array to populate with indicies of triangles.</param>
            <returns>True if a triangle was found</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
            <summary>
            Decompose the polygon into triangles
            </summary>
            <param name="contour">The list of points describing the polygon</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.SeidelDecomposer">
            <summary>
            Convex decomposition algorithm based on Raimund Seidel's paper "A simple and fast incremental randomized
            algorithm for computing trapezoidal decompositions and for triangulating polygons"
            See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
                      "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            </summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use. If you get bad results, try using a higher value. The default value is 0.001</param>
            <returns>A list of triangles</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartitionTrapezoid(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            </summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use. If you get bad results, try using a higher value. The default value is 0.001</param>
            <returns>A list of trapezoids</returns>
        </member>
        <member name="T:FarseerPhysics.Common.LineTools">
            <summary>
            Collection of helper methods for misc collisions.
            Does float tolerance and line collisions with lines and AABBs.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect2(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2@)">
             <summary>
            Check if the lines a0->a1 and b0->b1 cross.
            If they do, intersectionPoint will be filled
            with the point of crossing.
            
            Grazing lines should not return true.
             
             </summary>
             <param name="a0"></param>
             <param name="a1"></param>
             <param name="b0"></param>
             <param name="b1"></param>
             <param name="intersectionPoint"></param>
             <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,System.Boolean,System.Boolean,WaveEngine.Common.Math.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="point">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Boolean,System.Boolean,WaveEngine.Common.Math.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineSegmentVerticesIntersect(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,FarseerPhysics.Common.Vertices,System.Collections.Generic.List{WaveEngine.Common.Math.Vector2}@)">
            <summary>
            Get all intersections between a line segment and a list of vertices
            representing a polygon. The vertices reuse adjacent points, so for example
            edges one and two are between the first and second vertices and between the
            second and third vertices. The last edge is between vertex vertices.Count - 1
            and verts0. (ie, vertices from a Geometry or AABB)
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="vertices">The vertices, as described above</param>
            <param name="intersectionPoints">An list of intersection points. Any intersection points
            found will be added to this list.</param>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineSegmentAABBIntersect(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,FarseerPhysics.Collision.AABB,System.Collections.Generic.List{WaveEngine.Common.Math.Vector2}@)">
            <summary>
            Get all intersections between a line segment and an AABB. 
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="aabb">The AABB that is used for testing intersection.</param>
            <param name="intersectionPoints">An list of intersection points. Any intersection points found will be added to this list.</param>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.IsValid(System.Single)">
            <summary>
            This function is used to ensure that a floating point number is
            not a NaN or infinity.
            </summary>
            <param name="x">The x.</param>
            <returns>
            	<c>true</c> if the specified x is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.InvSqrt(System.Single)">
            <summary>
            This is a approximate yet fast inverse square-root.
            </summary>
            <param name="x">The x.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.VectorAngle(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Return the angle between two vectors on a plane
            The angle is from vector 1 to vector 2, positive anticlockwise
            The result is between -pi -> pi
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Area(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Area(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Collinear(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Determines if three vertices are collinear (ie. on a straight line)
            </summary>
            <param name="a">First vertex</param>
            <param name="b">Second vertex</param>
            <param name="c">Third vertex</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.FloatEquals(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is equal to another,
            within a certain tolerance.
            </summary>
            <param name="value1">The first floating point Value.</param>
            <param name="value2">The second floating point Value.</param>
            <param name="delta">The floating point tolerance.</param>
            <returns>True if the values are "equal", false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.FloatInRange(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is within a specified
            range of values (inclusive).
            </summary>
            <param name="value">The Value to check.</param>
            <param name="min">The minimum Value.</param>
            <param name="max">The maximum Value.</param>
            <returns>True if the Value is within the range specified,
            false otherwise.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Mat22">
            <summary>
            A 2-by-2 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct this matrix using scalars.
            </summary>
            <param name="a11">The a11.</param>
            <param name="a12">The a12.</param>
            <param name="a21">The a21.</param>
            <param name="a22">The a22.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(System.Single)">
            <summary>
            Construct this matrix using an angle. This matrix becomes
            an orthonormal rotation matrix.
            </summary>
            <param name="angle">The angle.</param>
        </member>
        <member name="P:FarseerPhysics.Common.Mat22.Angle">
            <summary>
            Extract the angle from this matrix (assumed to be
            a rotation matrix).
            </summary>
            <value></value>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Set(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Initialize this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Set(System.Single)">
            <summary>
            Initialize this matrix using an angle. This matrix becomes
            an orthonormal rotation matrix.
            </summary>
            <param name="angle">The angle.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.SetIdentity">
            <summary>
            Set this to the identity matrix.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Solve(WaveEngine.Common.Math.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Mat33">
            <summary>
            A 3-by-3 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.#ctor(WaveEngine.Common.Math.Vector3,WaveEngine.Common.Math.Vector3,WaveEngine.Common.Math.Vector3)">
            <summary>
            Construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
            <param name="c3">The c3.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.Solve33(WaveEngine.Common.Math.Vector3)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.Solve22(WaveEngine.Common.Math.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases. Solve only the upper
            2-by-2 matrix equation.
            </summary>
            <param name="b">The b.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Transform">
            <summary>
            A transform contains translation and rotation. It is used to represent
            the position and orientation of rigid frames.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.#ctor(WaveEngine.Common.Math.Vector2@,FarseerPhysics.Common.Mat22@)">
            <summary>
            Initialize using a position vector and a rotation matrix.
            </summary>
            <param name="position">The position.</param>
            <param name="r">The r.</param>
        </member>
        <member name="P:FarseerPhysics.Common.Transform.Angle">
            <summary>
            Calculate the angle that the rotation matrix represents.
            </summary>
            <value></value>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.SetIdentity">
            <summary>
            Set this to the identity transform.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.Set(WaveEngine.Common.Math.Vector2,System.Single)">
            <summary>
            Set this based on the position and angle.
            </summary>
            <param name="position">The position.</param>
            <param name="angle">The angle.</param>
        </member>
        <member name="T:FarseerPhysics.Common.Sweep">
            <summary>
            This describes the motion of a body/shape for TOI computation.
            Shapes are defined with respect to the body origin, which may
            no coincide with the center of mass. However, to support dynamics
            we must interpolate the center of mass position.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.A">
            <summary>
            World angles
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.Alpha0">
            <summary>
            Fraction of the current time step in the range [0,1]
            c0 and a0 are the positions at alpha0.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.C">
            <summary>
            Center world positions
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.LocalCenter">
            <summary>
            Local center of mass position
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.GetTransform(FarseerPhysics.Common.Transform@,System.Single)">
            <summary>
            Get the interpolated transform at a specific time.
            </summary>
            <param name="xf">The transform.</param>
            <param name="beta">beta is a factor in [0,1], where 0 indicates alpha0.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.Advance(System.Single)">
            <summary>
            Advance the sweep forward, yielding a new initial state.
            </summary>
            <param name="alpha">new initial time..</param>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.Normalize">
            <summary>
            Normalize the angles.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.Path">
            <summary>
            Path:
            Very similar to Vertices, but this
            class contains vectors describing
            control points on a Catmull-Rom
            curve.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Path.ControlPoints">
            <summary>
            All the points that makes up the curve
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor(WaveEngine.Common.Math.Vector2[])">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor(System.Collections.Generic.IList{WaveEngine.Common.Math.Vector2})">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="P:FarseerPhysics.Common.Path.Closed">
            <summary>
            True if the curve is closed.
            </summary>
            <value><c>true</c> if closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:FarseerPhysics.Common.Path.NextIndex(System.Int32)">
            <summary>
            Gets the next index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Translate(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Translates the control points by the specified vector.
            </summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Scale(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Scales the control points by the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Rotate(System.Single)">
            <summary>
            Rotate the control points by the defined value in radians.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.GetVertices(System.Int32)">
            <summary>
            Returns a set of points defining the
            curve with the specifed number of divisions
            between each control point.
            </summary>
            <param name="divisions">Number of divisions between each control point.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.GetPositionNormal(System.Single)">
            <summary>
            Gets the normal for the given time.
            </summary>
            <param name="time">The time</param>
            <returns>The normal.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.PhysicsLogic.RayDataComparer">
            <summary>
            This is a comprarer used for 
            detecting angle difference between rays
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:FarseerPhysics.Common.PhysicsLogic.Explosion" -->
        <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MaxEdgeOffset">
            <summary>
            Two degrees: maximum angle from edges to first ray tested
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.EdgeRatio">
            <summary>
            Ratio of arc length to angle from edges to first ray tested.
            Defaults to 1/40.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.IgnoreWhenInsideShape">
            <summary>
            Ignore Explosion if it happens inside a shape.
            Default value is false.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MaxAngle">
            <summary>
            Max angle between rays (used when segment is large).
            Defaults to 15 degrees
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MaxShapes">
            <summary>
            Maximum number of shapes involved in the explosion.
            Defaults to 100
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MinRays">
            <summary>
            How many rays per shape/body/segment.
            Defaults to 5
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.Explosion.Activate(WaveEngine.Common.Math.Vector2,System.Single,System.Single)">
            <summary>
            This makes the explosive explode
            </summary>
            <param name="pos">
            The position where the explosion happens
            </param>
            <param name="radius">
            The explosion radius
            </param>
            <param name="maxForce">
            The explosion force at the explosion point
            (then is inversely proportional to the square of the distance)
            </param>
            <returns>
            A dictionnary containing all the "exploded" fixtures
            with a list of the applied impulses
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.IgnorePhysicsLogic(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
            <summary>
            Ignores the controller. The controller has no effect on this body.
            </summary>
            <param name="type">The logic type.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.RestorePhysicsLogic(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
            <summary>
            Restore the controller. The controller affects this body.
            </summary>
            <param name="type">The logic type.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.IsPhysicsLogicIgnored(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="type">The logic type.</param>
            <returns>
            	<c>true</c> if the body has the specified flag; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.SplitShape(FarseerPhysics.Dynamics.Fixture,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Single,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Split a fixture into 2 vertice collections using the given entry and exit-point.
            </summary>
            <param name="fixture">The Fixture to split</param>
            <param name="entryPoint">The entry point - The start point</param>
            <param name="exitPoint">The exit point - The end point</param>
            <param name="splitSize">The size of the split. Think of this as the laser-width</param>
            <param name="first">The first collection of vertexes</param>
            <param name="second">The second collection of vertexes</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.Cut(FarseerPhysics.Dynamics.World,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Single)">
            <summary>
            This is a high-level function to cuts fixtures inside the given world, using the start and end points.
            Note: We don't support cutting when the start or end is inside a shape.
            </summary>
            <param name="world">The world.</param>
            <param name="start">The startpoint.</param>
            <param name="end">The endpoint.</param>
            <param name="thickness">The thickness of the cut</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Removes all collinear points on the polygon.
            </summary>
            <param name="vertices">The polygon that needs simplification.</param>
            <param name="collinearityTolerance">The collinearity tolerance.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(FarseerPhysics.Common.Vertices)">
            <summary>
            Removes all collinear points on the polygon.
            Has a default bias of 0
            </summary>
            <param name="vertices">The polygon that needs simplification.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DouglasPeuckerSimplify(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
            speed-up technique by using the Melkman convex hull.
            
            If you pass in 0, it will remove all collinear points
            </summary>
            <returns>The simplified polygon</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.MergeParallelEdges(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Merges all parallel edges in the list of vertices
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.MergeIdenticalPoints(FarseerPhysics.Common.Vertices)">
            <summary>
            Merges the identical points in the polygon.
            </summary>
            <param name="vertices">The vertices.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByDistance(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Reduces the polygon by distance.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="distance">The distance between points. Points closer than this will be 'joined'.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByNth(FarseerPhysics.Common.Vertices,System.Int32)">
            <summary>
            Reduces the polygon by removing the Nth vertex in the vertices list.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="nth">The Nth point to remove. Example: 5.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.PolygonManipulation.PolyClipType,FarseerPhysics.Common.PolygonManipulation.PolyClipError@)">
            <summary>
            Implements "A new algorithm for Boolean operations on general polygons" 
            available here: http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf
            Merges two polygons, a subject and a clip with the specified operation. Polygons may not be 
            self-intersecting.
            
            Warning: May yield incorrect results or even crash if polygons contain collinear points.
            </summary>
            <param name="subject">The subject polygon.</param>
            <param name="clip">The clip polygon, which is added, 
            substracted or intersected with the subject</param>
            <param name="clipType">The operation to be performed. Either
            Union, Difference or Intersection.</param>
            <param name="error">The error generated (if any)</param>
            <returns>A list of closed polygons, which make up the result of the clipping operation.
            Outer contours are ordered counter clockwise, holes are ordered clockwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateIntersections(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Calculates all intersections between two polygons.
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="slicedPoly1">Returns the first polygon with added intersection points.</param>
            <param name="slicedPoly2">Returns the second polygon with added intersection points.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(FarseerPhysics.Common.Vertices,System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the simplical chain corresponding to the input polygon.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateResultChain(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},FarseerPhysics.Common.PolygonManipulation.PolyClipType,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the characteristics function for all edges of
            the given simplical chains and builds the result chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.BuildPolygonsFromChain(System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{FarseerPhysics.Common.Vertices}@)">
            <summary>
            Calculates the polygon(s) from the result simplical chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(WaveEngine.Common.Math.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge,System.Single)">
            <summary>
            Needed to calculate the characteristics function of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateEdgeCharacter()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Needed for sorting multiple intersections points on the same edge.
            </summary>
            <remarks>Used by method <c>CalculateIntersections()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplexCoefficient(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Returns the coefficient of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateSimplicalChain()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointInSimplex(WaveEngine.Common.Math.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)">
            <summary>
            Winding number test for a point in a simplex.
            </summary>
            <param name="point">The point to be tested.</param>
            <param name="edge">The edge that the point is tested against.</param>
            <returns>False if the winding number is even and the point is outside
            the simplex and True otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Tests if a point lies on a line segment.
            </summary>
            <remarks>Used by method <c>CalculateBeta()</c>.</remarks>
        </member>
        <member name="T:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge">
            <summary>Specifies an Edge. Edges are used to represent simplicies in simplical chains</summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single)">
            <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single,WaveEngine.Common.Math.Vector2,System.Single)">
            <summary>
            Build vertices to represent an oriented box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
            <param name="center">the center of the box in local coordinates.</param>
            <param name="angle">the rotation of the box in local coordinates.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Creates a rounded rectangle with the specified width and height.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="xRadius">The rounding X radius.</param>
            <param name="yRadius">The rounding Y radius.</param>
            <param name="segments">The number of segments to subdivide the edges.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateLine(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Set this as a single edge.
            </summary>
            <param name="start">The first point.</param>
            <param name="end">The second point.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCircle(System.Single,System.Int32)">
            <summary>
            Creates a circle with the specified radius and number of edges.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles a circle</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateEllipse(System.Single,System.Single,System.Int32)">
            <summary>
            Creates a ellipse with the specified width, height and number of edges.
            </summary>
            <param name="xRadius">Width of the ellipse.</param>
            <param name="yRadius">Height of the ellipse.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles an ellipse</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + 2 * radius) of the capsule.</param>
            <param name="endRadius">Radius of the capsule ends.</param>
            <param name="edges">The number of edges of the capsule ends. The more edges, the more it resembles an capsule</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified  height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + radii) of the capsule.</param>
            <param name="topRadius">Radius of the top.</param>
            <param name="topEdges">The number of edges of the top. The more edges, the more it resembles an capsule</param>
            <param name="bottomRadius">Radius of bottom.</param>
            <param name="bottomEdges">The number of edges of the bottom. The more edges, the more it resembles an capsule</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateGear(System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Creates a gear shape with the specified radius and number of teeth.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfTeeth">The number of teeth.</param>
            <param name="tipPercentage">The tip percentage.</param>
            <param name="toothHeight">Height of the tooth.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Boolean)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="hullTolerance">The hull tolerance.</param>
            <param name="alphaTolerance">The alpha tolerance.</param>
            <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.WorldXmlSerializer">
            <summary>
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.DetectSquares(FarseerPhysics.Collision.AABB,System.Single,System.Single,System.SByte[0:,0:],System.Int32,System.Boolean)">
             <summary>
             Marching squares over the given domain using the mesh defined via the dimensions
                (wid,hei) to build a set of polygons such that f(x,y) less than 0, using the given number
                'bin' for recursive linear inteprolation along cell boundaries.
            
                if 'comb' is true, then the polygons will also be composited into larger possible concave
                polygons.
             </summary>
             <param name="domain"></param>
             <param name="cellWidth"></param>
             <param name="cellHeight"></param>
             <param name="f"></param>
             <param name="lerpCount"></param>
             <param name="combine"></param>
             <returns>The result.</returns>
        </member>
        <member name="F:FarseerPhysics.Common.MarchingSquares._lookMarch">
            Linearly interpolate between (x0 to x1) given a value at these coordinates (v0 and v1)
                        such as to approximate value(return) = 0
                    *
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.Xlerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            Recursive linear interpolation for use in marching squares *
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.Ylerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            Recursive linear interpolation for use in marching squares *
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.Square(System.Single)">
            Square value for use in marching squares *
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.MarchSquare(System.SByte[0:,0:],System.SByte[0:,0:],FarseerPhysics.Common.MarchingSquares.GeomPoly@,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            Look-up table to relate polygon key with the vertices that should be used for
                        the sub polygon in marching squares
                    *
            Perform a single celled marching square for for the given cell defined by (x0,y0) (x1,y1)
                        using the function f for recursive interpolation, given the look-up table 'fs' of
                        the values of 'f' at cell vertices with the result to be stored in 'poly' given the actual
                        coordinates of 'ax' 'ay' in the marching squares mesh.
                    *
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.combLeft(FarseerPhysics.Common.MarchingSquares.GeomPoly@,FarseerPhysics.Common.MarchingSquares.GeomPoly@)">
            Used in polygon composition to composit polygons into scan lines
                        Combining polya and polyb into one super-polygon stored in polya.
                    *
        </member>
        <member name="T:FarseerPhysics.Common.MarchingSquares.CxFastList`1">
            <summary>
            Designed as a complete port of CxFastList from CxStd.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Begin">
            <summary>
            Iterator to start of list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.End">
            <summary>
            Iterator to end of list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Front">
            <summary>
            Returns first element of list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Add(`0)">
            <summary>
            add object to list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Remove(`0)">
            <summary>
            remove object from list, returns true if an element was removed (O(n))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Pop">
            <summary>
            pop element from head of list (O(1)) Note: this does not return the object popped! 
            There is good reason to this, and it regards the Alloc list variants which guarantee 
            objects are released to the object pool. You do not want to retrieve an element 
            through pop or else that object may suddenly be used by another piece of code which 
            retrieves it from the object pool.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Insert(FarseerPhysics.Common.MarchingSquares.CxFastListNode{`0},`0)">
            <summary>
            insert object after 'node' returning an iterator to the inserted object.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Erase(FarseerPhysics.Common.MarchingSquares.CxFastListNode{`0},FarseerPhysics.Common.MarchingSquares.CxFastListNode{`0})">
            <summary>
            removes the element pointed to by 'node' with 'prev' being the previous iterator, 
            returning an iterator to the element following that of 'node' (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Empty">
            <summary>
            whether the list is empty (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Size">
            <summary>
            computes size of list (O(n))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Clear">
            <summary>
            empty the list (O(1) if CxMixList, O(n) otherwise)
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Has(`0)">
            <summary>
            returns true if 'value' is an element of the list (O(n))
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MarchingSquares.GeomPolyVal.Key">
            Associated polygon at coordinate *
            Key of original sub-polygon *
        </member>
        <member name="T:FarseerPhysics.Common.TerrainTester">
            <summary>
            Return true if the specified color is inside the terrain.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.MSTerrain">
            <summary>
            Simple class to maintain a terrain.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.World">
            <summary>
            World to manage terrain in.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.Center">
            <summary>
            Center of terrain in world units.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.Width">
            <summary>
            Width of terrain in world units.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.Height">
            <summary>
            Height of terrain in world units.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.PointsPerUnit">
            <summary>
            Points per each world unit used to define the terrain in the point cloud.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.CellSize">
            <summary>
            Points per cell.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.SubCellSize">
            <summary>
            Points per sub cell.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.Iterations">
            <summary>
            Number of iterations to perform in the Marching Squares algorithm.
            Note: More then 3 has almost no effect on quality.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain.Decomposer">
            <summary>
            Decomposer to use when regenerating terrain. Can be changed on the fly without consequence.
            Note: Some decomposerers are unstable.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain._terrainMap">
            <summary>
            Point cloud defining the terrain.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.MSTerrain._bodyMap">
            <summary>
            Generated bodies.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MSTerrain.Initialize">
            <summary>
            Initialize the terrain for use.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MSTerrain.ApplyData(System.SByte[0:,0:],WaveEngine.Common.Math.Vector2)">
            <summary>
            Apply a texture to the terrain using the specified TerrainTester.
            </summary>
            <param name="position">Top left position of the texture relative to the terrain.</param>
        </member>
        <member name="M:FarseerPhysics.Common.MSTerrain.ModifyTerrain(WaveEngine.Common.Math.Vector2,System.SByte)">
            <summary>
            Modify a single point in the terrain.
            </summary>
            <param name="location">World location to modify. Automatically clipped.</param>
            <param name="value">-1 = inside terrain, 1 = outside terrain</param>
        </member>
        <member name="M:FarseerPhysics.Common.MSTerrain.RegenerateTerrain">
            <summary>
            Regenerate the terrain.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.VerticesDetectionType">
            <summary>
            The detection type affects the resulting polygon data.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.VerticesDetectionType.Integrated">
            <summary>
            Holes are integrated into the main polygon.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.VerticesDetectionType.Separated">
            <summary>
            The data of the main polygon and hole polygons is returned separately.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.DetectedVertices">
            <summary>
            Detected vertices of a single polygon.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.TextureConverter">
            <summary>
            
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.TextureConverter.ClosePixels">
            <summary>
            This array is ment to be readonly.
            It's not because it is accessed very frequently.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.TextureConverter.PolygonDetectionType">
            <summary>
            Get or set the polygon detection type.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.TextureConverter.HoleDetection">
            <summary>
            Will detect texture 'holes' if set to true. Slows down the detection. Default is false.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.TextureConverter.MultipartDetection">
            <summary>
            Will detect texture multiple 'solid' isles if set to true. Slows down the detection. Default is false.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.TextureConverter.PixelOffsetOptimization">
            <summary>
            Will optimize the vertex positions along the interpolated normal between two edges about a half pixel (post processing). Default is false.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.TextureConverter.Transform">
            <summary>
            Can be used for scaling.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.TextureConverter.AlphaTolerance">
            <summary>
            Alpha (coverage) tolerance. Default is 20: Every pixel with a coverage value equal or greater to 20 will be counts as solid.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.TextureConverter.HullTolerance">
            <summary>
            Default is 1.5f.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.SetTextureData(System.UInt32[],System.Int32)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="width"></param>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.DetectVertices(System.UInt32[],System.Int32)">
            <summary>
            Detects the vertices of the supplied texture data. (PolygonDetectionType.Integrated)
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Boolean)">
            <summary>
            Detects the vertices of the supplied texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Detects the vertices of the supplied texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <param name="hullTolerance">The hull tolerance.</param>
            <param name="alphaTolerance">The alpha tolerance.</param>
            <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.SearchHoleEntrance(FarseerPhysics.Common.Vertices,System.Nullable{WaveEngine.Common.Math.Vector2})">
            <summary>
            Function to search for an entrance point of a hole in a polygon. It searches the polygon from top to bottom between the polygon edges.
            </summary>
            <param name="polygon">The polygon to search in.</param>
            <param name="lastHoleEntrance">The last entrance point.</param>
            <returns>The next holes entrance point. Null if ther are no holes.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.SearchCrossingEdges(FarseerPhysics.Common.Vertices,System.Int32)">
            <summary>
            Searches the polygon for the x coordinates of the edges that cross the specified y coordinate.
            </summary>
            <param name="polygon">Polygon to search in.</param>
            <param name="y">Y coordinate to check for edges.</param>
            <returns>Descending sorted list of x coordinates of edges that cross the specified y coordinate.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.CreateSimplePolygon(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            
            </summary>
            <param name="entrance"></param>
            <param name="last"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.TextureConverter.SearchNextHullEntrance(System.Collections.Generic.List{FarseerPhysics.Common.DetectedVertices},WaveEngine.Common.Math.Vector2,System.Nullable{WaveEngine.Common.Math.Vector2}@)">
            <summary>
            Searches for the next shape.
            </summary>
            <param name="detectedPolygons">Already detected polygons.</param>
            <param name="start">Search start coordinate.</param>
            <param name="entrance">Returns the found entrance coordinate. Null if no other shapes found.</param>
            <returns>True if a new shape was found.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.NextIndex(System.Int32)">
            <summary>
            Nexts the index.
            </summary>
            <param name="index">The index.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index.
            </summary>
            <param name="index">The index.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetSignedArea">
            <summary>
            Gets the signed area.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetArea">
            <summary>
            Gets the area.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetCentroid">
            <summary>
            Gets the centroid.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetRadius">
            <summary>
            Gets the radius based on area.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetCollisionBox">
            <summary>
            Returns an AABB for vertex.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Translate(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Translates the vertices with the specified vector.
            </summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Scale(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Scales the vertices with the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Rotate(System.Single)">
            <summary>
            Rotate the vertices with the defined value in radians.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.IsConvex">
            <summary>
            Assuming the polygon is simple; determines whether the polygon is convex.
            NOTE: It will also return false if the input contains colinear edges.
            </summary>
            <returns>
            	<c>true</c> if it is convex; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.ForceCounterClockWise">
            <summary>
            Forces counter clock wise order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.IsSimple">
            <summary>
            Check for edge crossings
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.CheckPolygon">
             <summary>
             Checks if polygon is valid for use in Box2d engine.
             Last ditch effort to ensure no invalid polygons are
             added to world geometry.
            
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.  This won't
             be very efficient, and a lot of it is redundant when
             other tools in this section are used.
             </summary>
             <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.TraceEdge(FarseerPhysics.Common.Vertices)">
            <summary>
            Trace the edge of a non-simple polygon and return a simple polygon.
            
            Method:
            Start at vertex with minimum y (pick maximum x one if there are two).
            We aim our "lastDir" vector at (1.0, 0)
            We look at the two rays going off from our start vertex, and follow whichever
            has the smallest angle (in -Pi . Pi) wrt lastDir ("rightest" turn)
            Loop until we hit starting vertex:
            We add our current vertex to the list.
            We check the seg from current vertex to next vertex for intersections
            - if no intersections, follow to next vertex and continue
            - if intersections, pick one with minimum distance
            - if more than one, pick one with "rightest" next point (two possibilities for each)
            </summary>
            <param name="verts">The vertices.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.ProjectToAxis(WaveEngine.Common.Math.Vector2@,System.Single@,System.Single@)">
            <summary>
            Projects to axis.
            </summary>
            <param name="axis">The axis.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PointInPolygon(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Winding number test for a point in a polygon.
            </summary>
            See more info about the algorithm here: http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm
            <param name="point">The point to be tested.</param>
            <returns>-1 if the winding number is zero and the point is outside
            the polygon, 1 if the point is inside the polygon, and 0 if the point
            is on the polygons edge.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PointInPolygonAngle(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
            If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
            ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2 
            </summary>
        </member>
        <member name="T:FarseerPhysics.Factories.PathManager">
            <summary>
            An easy to use manager for creating paths.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.ConvertPathToEdges(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Int32)">
            <summary>
            Convert a path into a set of edges and attaches them to the specified body.
            Note: use only for static edges.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.ConvertPathToPolygon(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Int32)">
            <summary>
            Convert a closed path into a polygon.
            Convex decomposition is automatically performed.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="density">The density.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.EvenlyDistributeShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,System.Collections.Generic.IEnumerable{FarseerPhysics.Collision.Shapes.Shape},FarseerPhysics.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shapes">The shapes.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.EvenlyDistributeShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,FarseerPhysics.Collision.Shapes.Shape,FarseerPhysics.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shape">The shape.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData">The user data.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.MoveBodyOnPath(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Single,System.Single)">
            <summary>
            Moves the body on the path.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="time">The time.</param>
            <param name="strength">The strength.</param>
            <param name="timeStep">The time step.</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.AttachBodiesWithRevoluteJoint(FarseerPhysics.Dynamics.World,System.Collections.Generic.List{FarseerPhysics.Dynamics.Body},WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Boolean,System.Boolean)">
            <summary>
            Attaches the bodies with revolute joints.
            </summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.AttachBodiesWithSliderJoint(FarseerPhysics.Dynamics.World,System.Collections.Generic.List{FarseerPhysics.Dynamics.Body},WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Boolean,System.Boolean,System.Single,System.Single)">
            <summary>
            Attaches the bodies with revolute joints.
            </summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
            <param name="minLength">Minimum length of the slider joint.</param>
            <param name="maxLength">Maximum length of the slider joint.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.BodyFactory.CreateCapsule(FarseerPhysics.Dynamics.World,System.Single,System.Single,System.Int32,System.Single,System.Int32,System.Single,WaveEngine.Common.Math.Vector2,System.Object)">
            <summary>
            Creates a capsule.
            Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
            </summary>
            <param name="world">The world.</param>
            <param name="height">The height.</param>
            <param name="topRadius">The top radius.</param>
            <param name="topEdges">The top edges.</param>
            <param name="bottomRadius">The bottom radius.</param>
            <param name="bottomEdges">The bottom edges.</param>
            <param name="density">The density.</param>
            <param name="position">The position.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle(FarseerPhysics.Dynamics.World,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,WaveEngine.Common.Math.Vector2,System.Object)">
            <summary>
            Creates a rounded rectangle.
            Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
            </summary>
            <param name="world">The world.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="xRadius">The x radius.</param>
            <param name="yRadius">The y radius.</param>
            <param name="segments">The segments.</param>
            <param name="density">The density.</param>
            <param name="position">The position.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.BodyFactory.CreateBreakableBody(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Vertices,System.Single,WaveEngine.Common.Math.Vector2,System.Object)">
            <summary>
            Creates a breakable body. You would want to remove collinear points before using this.
            </summary>
            <param name="world">The world.</param>
            <param name="vertices">The vertices.</param>
            <param name="density">The density.</param>
            <param name="position">The position.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Factories.FixtureFactory">
            <summary>
            An easy to use factory for creating bodies
            </summary>
        </member>
        <member name="T:FarseerPhysics.Factories.JointFactory">
            <summary>
            An easy to use factory for using joints.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a revolute joint.
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localAnchorB">The anchor of bodyB in local coordinates</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a revolute joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="anchor"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateFixedRevoluteJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates the fixed revolute joint.
            </summary>
            <param name="world">The world.</param>
            <param name="body">The body.</param>
            <param name="bodyAnchor">The body anchor.</param>
            <param name="worldAnchor">The world anchor.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateWeldJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a weld joint
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localAnchor"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateWeldJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a weld joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a prsimatic joint
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <param name="axis"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a prismatic joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <param name="axis"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateLineJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a line joint
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="anchor"></param>
            <param name="axis"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateLineJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Creates a line joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <param name="axis"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateAngleJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body)">
            <summary>
            Creates an angle joint.
            </summary>
            <param name="world">The world.</param>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateFixedAngleJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body)">
            <summary>
            Creates a fixed angle joint.
            </summary>
            <param name="world">The world.</param>
            <param name="body">The body.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Factories.LinkFactory.CreateChain(FarseerPhysics.Dynamics.World,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Single,System.Single,System.Boolean,System.Boolean,System.Int32,System.Single)">
            <summary>
            Creates a chain.
            </summary>
            <param name="world">The world.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="linkWidth">The width.</param>
            <param name="linkHeight">The height.</param>
            <param name="fixStart">if set to <c>true</c> [fix start].</param>
            <param name="fixEnd">if set to <c>true</c> [fix end].</param>
            <param name="numberOfLinks">The number of links.</param>
            <param name="linkDensity">The link density.</param>
            <returns>The result.</returns>
        </member>
        <member name="F:FarseerPhysics.Controllers.BuoyancyController.AngularDragCoefficient">
            <summary>
            Controls the rotational drag that the fluid exerts on the bodies within it. Use higher values will simulate thick fluid, like honey, lower values to
            simulate water-like fluids. 
            </summary>
        </member>
        <member name="F:FarseerPhysics.Controllers.BuoyancyController.Density">
            <summary>
            Density of the fluid. Higher values will make things more buoyant, lower values will cause things to sink.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Controllers.BuoyancyController.LinearDragCoefficient">
            <summary>
            Controls the linear drag that the fluid exerts on the bodies within it.  Use higher values will simulate thick fluid, like honey, lower values to
            simulate water-like fluids.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Controllers.BuoyancyController.Velocity">
            <summary>
            Acts like waterflow. Defaults to 0,0.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Controllers.BuoyancyController.#ctor(FarseerPhysics.Collision.AABB,System.Single,System.Single,System.Single,WaveEngine.Common.Math.Vector2)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Controllers.BuoyancyController"/> class.
            </summary>
            <param name="container">Only bodies inside this AABB will be influenced by the controller</param>
            <param name="density">Density of the fluid</param>
            <param name="linearDragCoefficient">Linear drag coefficient of the fluid</param>
            <param name="rotationalDragCoefficient">Rotational drag coefficient of the fluid</param>
            <param name="gravity">The direction gravity acts. Buoyancy force will act in opposite direction of gravity.</param>
        </member>
        <member name="M:FarseerPhysics.Controllers.ControllerFilter.IgnoreController(FarseerPhysics.Controllers.ControllerType)">
            <summary>
            Ignores the controller. The controller has no effect on this body.
            </summary>
            <param name="controller">The controller type.</param>
        </member>
        <member name="M:FarseerPhysics.Controllers.ControllerFilter.RestoreController(FarseerPhysics.Controllers.ControllerType)">
            <summary>
            Restore the controller. The controller affects this body.
            </summary>
            <param name="controller">The controller type.</param>
        </member>
        <member name="M:FarseerPhysics.Controllers.ControllerFilter.IsControllerIgnored(FarseerPhysics.Controllers.ControllerType)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="controller">The controller type.</param>
            <returns>
            	<c>true</c> if the body has the specified flag; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FarseerPhysics.Controllers.VelocityLimitController">
            <summary>
            Put a limit on the linear (translation - the movespeed) and angular (rotation) velocity
            of bodies added to this controller.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Controllers.VelocityLimitController.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Controllers.VelocityLimitController"/> class.
            Sets the max linear velocity to Settings.MaxTranslation
            Sets the max angular velocity to Settings.MaxRotation
            </summary>
        </member>
        <member name="M:FarseerPhysics.Controllers.VelocityLimitController.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Controllers.VelocityLimitController"/> class.
            Pass in 0 or float.MaxValue to disable the limit.
            maxAngularVelocity = 0 will disable the angular velocity limit.
            </summary>
            <param name="maxLinearVelocity">The max linear velocity.</param>
            <param name="maxAngularVelocity">The max angular velocity.</param>
        </member>
        <member name="P:FarseerPhysics.Controllers.VelocityLimitController.MaxAngularVelocity">
            <summary>
            Gets or sets the max angular velocity.
            </summary>
            <value>The max angular velocity.</value>
        </member>
        <member name="P:FarseerPhysics.Controllers.VelocityLimitController.MaxLinearVelocity">
            <summary>
            Gets or sets the max linear velocity.
            </summary>
            <value>The max linear velocity.</value>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.Shape">
            <summary>
            Draw shapes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.Joint">
            <summary>
            Draw joint connections.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.AABB">
            <summary>
            Draw axis aligned bounding boxes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.Pair">
            <summary>
            Draw broad-phase pairs.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.CenterOfMass">
            <summary>
            Draw center of mass frame.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.DebugPanel">
            <summary>
            Draw useful debug data such as timings and number of bodies, joints, contacts and more.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.ContactPoints">
            <summary>
            Draw contact points between colliding bodies.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.ContactNormals">
            <summary>
            Draw contact normals. Need ContactPoints to be enabled first.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.PolygonPoints">
            <summary>
            Draws the vertices of polygons.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.PerformanceGraph">
            <summary>
            Draws the performance graph.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.Controllers">
            <summary>
            Draws controllers.
            </summary>
        </member>
        <member name="T:FarseerPhysics.DebugView">
            Implement and register this class with a World to provide debug drawing of physics
            entities in your game.
        </member>
        <member name="P:FarseerPhysics.DebugView.Flags">
            <summary>
            Gets or sets the debug view flags.
            </summary>
            <value>The flags.</value>
        </member>
        <member name="M:FarseerPhysics.DebugView.AppendFlags(FarseerPhysics.DebugViewFlags)">
            <summary>
            Append flags to the current flags.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.RemoveFlags(FarseerPhysics.DebugViewFlags)">
            <summary>
            Remove flags from the current flags.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawPolygon(WaveEngine.Common.Math.Vector2[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Draw a closed polygon provided in CCW order.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="count">The vertex count.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawSolidPolygon(WaveEngine.Common.Math.Vector2[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Draw a solid closed polygon provided in CCW order.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="count">The vertex count.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawCircle(WaveEngine.Common.Math.Vector2,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draw a circle.
            </summary>
            <param name="center">The center.</param>
            <param name="radius">The radius.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawSolidCircle(WaveEngine.Common.Math.Vector2,System.Single,WaveEngine.Common.Math.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draw a solid circle.
            </summary>
            <param name="center">The center.</param>
            <param name="radius">The radius.</param>
            <param name="axis">The axis.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawSegment(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draw a line segment.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawTransform(FarseerPhysics.Common.Transform@)">
            <summary>
            Draw a transform. Choose your own length scale.
            </summary>
            <param name="transform">The transform.</param>
        </member>
        <member name="T:FarseerPhysics.Dynamics.BodyType">
            <summary>
            The body type.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.BodyType.Static">
            <summary>
            Zero velocity, may be manually moved. Note: even static bodies have mass.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.BodyType.Kinematic">
            <summary>
            Zero mass, non-zero velocity set by user, moved by solver
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.BodyType.Dynamic">
            <summary>
            Positive mass, non-zero velocity determined by forces, moved by solver
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Revolutions">
            <summary>
            Gets the total number revolutions the body has made.
            </summary>
            <value>The revolutions.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.BodyType">
            <summary>
            Gets or sets the body type.
            </summary>
            <value>The type of body.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.LinearVelocity">
            <summary>
            Get or sets the linear velocity of the center of mass.
            </summary>
            <value>The linear velocity.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.AngularVelocity">
            <summary>
            Gets or sets the angular velocity. Radians/second.
            </summary>
            <value>The angular velocity.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.LinearDamping">
            <summary>
            Gets or sets the linear damping.
            </summary>
            <value>The linear damping.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.AngularDamping">
            <summary>
            Gets or sets the angular damping.
            </summary>
            <value>The angular damping.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.IsBullet">
            <summary>
            Gets or sets a value indicating whether this body should be included in the CCD solver.
            </summary>
            <value><c>true</c> if this instance is included in CCD; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.SleepingAllowed">
            <summary>
            You can disable sleeping on this body. If you disable sleeping, the
            body will be woken.
            </summary>
            <value><c>true</c> if sleeping is allowed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Awake">
            <summary>
            Set the sleep state of the body. A sleeping body has very
            low CPU cost.
            </summary>
            <value><c>true</c> if awake; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Enabled">
            <summary>
            Set the active state of the body. An inactive body is not
            simulated and cannot be collided with or woken up.
            If you pass a flag of true, all fixtures will be added to the
            broad-phase.
            If you pass a flag of false, all fixtures will be removed from
            the broad-phase and all contacts will be destroyed.
            Fixtures and joints are otherwise unaffected. You may continue
            to create/destroy fixtures and joints on inactive bodies.
            Fixtures on an inactive body are implicitly inactive and will
            not participate in collisions, ray-casts, or queries.
            Joints connected to an inactive body are implicitly inactive.
            An inactive body is still owned by a b2World object and remains
            in the body list.
            </summary>
            <value><c>true</c> if active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.FixedRotation">
            <summary>
            Set this body to have fixed rotation. This causes the mass
            to be reset.
            </summary>
            <value><c>true</c> if it has fixed rotation; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.FixtureList">
            <summary>
            Gets all the fixtures attached to this body.
            </summary>
            <value>The fixture list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.JointList">
            <summary>
            Get the list of all joints attached to this body.
            </summary>
            <value>The joint list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.ContactList">
            <summary>
            Get the list of all contacts attached to this body.
            Warning: this list changes during the time step and you may
            miss some collisions if you don't use ContactListener.
            </summary>
            <value>The contact list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.UserData">
            <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
            <value>The user data.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Position">
            <summary>
            Get the world body origin position.
            </summary>
            <returns>Return the world position of the body's origin.</returns>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Rotation">
            <summary>
            Get the angle in radians.
            </summary>
            <returns>Return the current world rotation angle in radians.</returns>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.IsStatic">
            <summary>
            Gets or sets a value indicating whether this body is static.
            </summary>
            <value><c>true</c> if this instance is static; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.IgnoreGravity">
            <summary>
            Gets or sets a value indicating whether this body ignores gravity.
            </summary>
            <value><c>true</c> if  it ignores gravity; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.WorldCenter">
            <summary>
            Get the world position of the center of mass.
            </summary>
            <value>The world position.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.LocalCenter">
            <summary>
            Get the local position of the center of mass.
            </summary>
            <value>The local position.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Mass">
            <summary>
            Gets or sets the mass. Usually in kilograms (kg).
            </summary>
            <value>The mass.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Inertia">
            <summary>
            Get or set the rotational inertia of the body about the local origin. usually in kg-m^2.
            </summary>
            <value>The inertia.</value>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ResetDynamics">
            <summary>
            Resets the dynamics of this body.
            Sets torque, force and linear/angular velocity to 0
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.CreateFixture(FarseerPhysics.Collision.Shapes.Shape)">
            <summary>
            Creates a fixture and attach it to this body.
            If the density is non-zero, this function automatically updates the mass of the body.
            Contacts are not created until the next time step.
            Warning: This function is locked during callbacks.
            </summary>
            <param name="shape">The shape.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.CreateFixture(FarseerPhysics.Collision.Shapes.Shape,System.Object)">
            <summary>
            Creates a fixture and attach it to this body.
            If the density is non-zero, this function automatically updates the mass of the body.
            Contacts are not created until the next time step.
            Warning: This function is locked during callbacks.
            </summary>
            <param name="shape">The shape.</param>
            <param name="userData">Application specific data</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.DestroyFixture(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Destroy a fixture. This removes the fixture from the broad-phase and
            destroys all contacts associated with this fixture. This will
            automatically adjust the mass of the body if the body is dynamic and the
            fixture has positive density.
            All fixtures attached to a body are implicitly destroyed when the body is destroyed.
            Warning: This function is locked during callbacks.
            </summary>
            <param name="fixture">The fixture to be removed.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.SetTransform(WaveEngine.Common.Math.Vector2@,System.Single)">
            <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.SetTransform(WaveEngine.Common.Math.Vector2,System.Single)">
            <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.SetTransformIgnoreContacts(WaveEngine.Common.Math.Vector2@,System.Single)">
            <summary>
            For teleporting a body without considering new contacts immediately.
            </summary>
            <param name="position">The position.</param>
            <param name="angle">The angle.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetTransform(FarseerPhysics.Common.Transform@)">
            <summary>
            Get the body transform for the body's origin.
            </summary>
            <param name="transform">The transform of the body's origin.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Applies a force at the center of mass.
            </summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(WaveEngine.Common.Math.Vector2)">
            <summary>
            Applies a force at the center of mass.
            </summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyTorque(System.Single)">
            <summary>
            Apply a torque. This affects the angular velocity
            without affecting the linear velocity of the center of mass.
            This wakes up the body.
            </summary>
            <param name="torque">The torque about the z-axis (out of the screen), usually in N-m.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(WaveEngine.Common.Math.Vector2)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            It also modifies the angular velocity if the point of application
            is not at the center of mass.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(WaveEngine.Common.Math.Vector2@,WaveEngine.Common.Math.Vector2@)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            It also modifies the angular velocity if the point of application
            is not at the center of mass.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyAngularImpulse(System.Single)">
            <summary>
            Apply an angular impulse.
            </summary>
            <param name="impulse">The angular impulse in units of kg*m*m/s.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ResetMassData">
            <summary>
            This resets the mass properties to the sum of the mass properties of the fixtures.
            This normally does not need to be called unless you called SetMassData to override
            the mass and you later want to reset the mass.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldPoint(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
            <param name="localPoint">A point on the body measured relative the the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldPoint(WaveEngine.Common.Math.Vector2)">
            <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
            <param name="localPoint">A point on the body measured relative the the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldVector(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Get the world coordinates of a vector given the local coordinates.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldVector(WaveEngine.Common.Math.Vector2)">
            <summary>
            Get the world coordinates of a vector given the local coordinates.
            </summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalPoint(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Gets a local point relative to the body's origin given a world point.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalPoint(WaveEngine.Common.Math.Vector2)">
            <summary>
            Gets a local point relative to the body's origin given a world point.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalVector(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Gets a local vector given a world vector.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalVector(WaveEngine.Common.Math.Vector2)">
            <summary>
            Gets a local vector given a world vector.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromWorldPoint(WaveEngine.Common.Math.Vector2)">
            <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromWorldPoint(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromLocalPoint(WaveEngine.Common.Math.Vector2)">
            <summary>
            Get the world velocity of a local point.
            </summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromLocalPoint(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Get the world velocity of a local point.
            </summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ShouldCollide(FarseerPhysics.Dynamics.Body)">
            <summary>
            This is used to prevent connected bodies from colliding.
            It may lie, depending on the collideConnected flag.
            </summary>
            <param name="other">The other body.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Dynamics.BreakableBody">
            <summary>
            A type of body that supports multiple fixtures that can break apart.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.BreakableBody.Strength">
            <summary>
            The force needed to break the body apart.
            Default: 500
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.BeginContact">
            <summary>
            Fires when a contact is created
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.ContactFilter">
            <summary>
            The filter used by the contact manager.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.EndContact">
            <summary>
            Fires when a contact is deleted
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.OnBroadphaseCollision">
            <summary>
            Fires when the broadphase detects that two Fixtures are close to each other.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.PostSolve">
            <summary>
            Fires after the solver has run
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.PreSolve">
            <summary>
            Fires before the solver runs
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Contacts.ContactEdge">
            <summary>
            A contact edge is used to connect bodies and contacts together
            in a contact graph where each body is a node and each contact
            is an edge. A contact edge belongs to a doubly linked list
            maintained in each attached body. Each contact has two contact
            nodes, one for each attached body.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Contact">
            <summary>
            The contact
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Next">
            <summary>
            The next contact edge in the body's contact list
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Other">
            <summary>
            Provides quick access to the other body attached.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Prev">
            <summary>
            The previous contact edge in the body's contact list
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Island">
            <summary>
            Used when crawling contact graph when forming islands.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching">
            <summary>
            Set when the shapes are touching.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled">
            <summary>
            This contact can be disabled (by user)
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter">
            <summary>
            This contact needs filtering because a fixture filter was changed.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.BulletHit">
            <summary>
            This bullet contact had a TOI event
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI">
            <summary>
            This contact has a valid TOI i the field TOI
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Contacts.Contact">
            <summary>
            The class manages contact between two shapes. A contact exists for each overlapping
            AABB in the broad-phase (except if filtered). Therefore a contact object may exist
            that has no contact points.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.Enabled">
            Enable/disable this contact. This can be used inside the pre-solve
            contact listener. The contact is only disabled for the current
            time step (or sub-step in continuous collisions).
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.ChildIndexA">
            <summary>
            Get the child primitive index for fixture A.
            </summary>
            <value>The child index A.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.ChildIndexB">
            <summary>
            Get the child primitive index for fixture B.
            </summary>
            <value>The child index B.</value>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.GetManifold(FarseerPhysics.Collision.Manifold@)">
            <summary>
            Get the contact manifold. Do not modify the manifold unless you understand the
            internals of Box2D.
            </summary>
            <param name="manifold">The manifold.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.GetWorldManifold(WaveEngine.Common.Math.Vector2@,FarseerPhysics.Common.FixedArray2{WaveEngine.Common.Math.Vector2}@)">
            <summary>
            Gets the world manifold.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.IsTouching">
            <summary>
            Determines whether this contact is touching.
            </summary>
            <returns>
            	<c>true</c> if this instance is touching; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.FlagForFiltering">
            <summary>
            Flag this contact for filtering. Filtering will occur the next time step.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.Update(FarseerPhysics.Dynamics.ContactManager)">
            <summary>
            Update the contact manifold and touching status.
            Note: do not assume the fixture AABBs are overlapping or are valid.
            </summary>
            <param name="contactManager">The contact manager.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.Evaluate(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Common.Transform@,FarseerPhysics.Common.Transform@)">
            <summary>
            Evaluate this contact with your own manifold and transforms.   
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="transformA">The first transform.</param>
            <param name="transformB">The second transform.</param>
        </member>
        <member name="T:FarseerPhysics.Dynamics.FixtureProxy">
            <summary>
            This proxy is used internally to connect fixtures to the broad-phase.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Fixture">
            <summary>
            A fixture is used to attach a Shape to a body for collision detection. A fixture
            inherits its transform from its parent. Fixtures hold additional non-geometric data
            such as friction, collision filters, etc.
            Fixtures are created via Body.CreateFixture.
            Warning: You cannot reuse fixtures.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Fixture.AfterCollision">
            <summary>
            Fires after two shapes has collided and are solved. This gives you a chance to get the impact force.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Fixture.BeforeCollision">
            <summary>
            Fires when two fixtures are close to each other.
            Due to how the broadphase works, this can be quite inaccurate as shapes are approximated using AABBs.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Fixture.OnCollision">
            <summary>
            Fires when two shapes collide and a contact is created between them.
            Note that the first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Fixture.OnSeparation">
            <summary>
            Fires when two shapes separate and a contact is removed between them.
            Note that the first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.CollisionGroup">
            <summary>
            Defaults to 0
            
            If Settings.UseFPECollisionCategories is set to false:
            Collision groups allow a certain group of objects to never collide (negative)
            or always collide (positive). Zero means no collision group. Non-zero group
            filtering always wins against the mask bits.
            
            If Settings.UseFPECollisionCategories is set to true:
            If 2 fixtures are in the same collision group, they will not collide.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.CollidesWith">
            <summary>
            Defaults to Category.All
            
            The collision mask bits. This states the categories that this
            fixture would accept for collision.
            Use Settings.UseFPECollisionCategories to change the behavior.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.CollisionCategories">
            <summary>
            The collision categories this fixture is a part of.
            
            If Settings.UseFPECollisionCategories is set to false:
            Defaults to Category.Cat1
            
            If Settings.UseFPECollisionCategories is set to true:
            Defaults to Category.All
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.ShapeType">
            <summary>
            Get the type of the child Shape. You can use this to down cast to the concrete Shape.
            </summary>
            <value>The type of the shape.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Shape">
            <summary>
            Get the child Shape. You can modify the child Shape, however you should not change the
            number of vertices because this will crash some collision caching mechanisms.
            </summary>
            <value>The shape.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.IsSensor">
            <summary>
            Gets or sets a value indicating whether this fixture is a sensor.
            </summary>
            <value><c>true</c> if this instance is a sensor; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Body">
            <summary>
            Get the parent body of this fixture. This is null if the fixture is not attached.
            </summary>
            <value>The body.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.UserData">
            <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
            <value>The user data.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Friction">
            <summary>
            Get or set the coefficient of friction.
            </summary>
            <value>The friction.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Restitution">
            <summary>
            Get or set the coefficient of restitution.
            </summary>
            <value>The restitution.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.FixtureId">
            <summary>
            Gets a unique ID for this fixture.
            </summary>
            <value>The fixture id.</value>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.RestoreCollisionWith(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Restores collisions between this fixture and the provided fixture.
            </summary>
            <param name="fixture">The fixture.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.IgnoreCollisionWith(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Ignores collisions between this fixture and the provided fixture.
            </summary>
            <param name="fixture">The fixture.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.IsFixtureIgnored(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Determines whether collisions are ignored between this fixture and the provided fixture.
            </summary>
            <param name="fixture">The fixture.</param>
            <returns>
            	<c>true</c> if the fixture is ignored; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.Refilter">
            <summary>
            Contacts are persistant and will keep being persistant unless they are
            flagged for filtering.
            This methods flags all contacts associated with the body for filtering.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.TestPoint(WaveEngine.Common.Math.Vector2@)">
            <summary>
            Test a point for containment in this fixture.
            </summary>
            <param name="point">A point in world coordinates.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,System.Int32)">
            <summary>
            Cast a ray against this Shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="childIndex">Index of the child.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.GetAABB(FarseerPhysics.Collision.AABB@,System.Int32)">
            <summary>
            Get the fixture's AABB. This AABB may be enlarge and/or stale.
            If you need a more accurate AABB, compute it using the Shape and
            the body transform.
            </summary>
            <param name="aabb">The aabb.</param>
            <param name="childIndex">Index of the child.</param>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Island">
            <summary>
            This is an internal class.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.AngleJoint">
            <summary>
            Maintains a fixed angle between two bodies
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.DistanceJoint">
            <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.DistanceJoint.LocalAnchorA">
            <summary>
            The local anchor point relative to bodyA's origin.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.DistanceJoint.LocalAnchorB">
            <summary>
            The local anchor point relative to bodyB's origin.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.DistanceJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            @warning Do not use a zero or short length.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="localAnchorA">The first body anchor</param>
            <param name="localAnchorB">The second body anchor</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.Length">
            <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.Frequency">
            <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint">
            <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.LocalAnchorA">
            <summary>
            The local anchor point relative to bodyA's origin.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.#ctor(FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            @warning Do not use a zero or short length.
            </summary>
            <param name="body">The body.</param>
            <param name="bodyAnchor">The body anchor.</param>
            <param name="worldAnchor">The world anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.Length">
            <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.Frequency">
            <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedFrictionJoint">
            <summary>
            Friction joint. This is used for top-down friction.
            It provides 2D translational friction and angular friction.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.FixedFrictionJoint.MaxForce">
            <summary>
            The maximum friction force in N.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.FixedFrictionJoint.MaxTorque">
            <summary>
            The maximum friction torque in N-m.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedMouseJoint">
            <summary>
            A mouse joint is used to make a point on a body track a
            specified world point. This a soft constraint with a maximum
            force. This allows the constraint to stretch and without
            applying huge forces.
            NOTE: this joint is not documented in the manual because it was
            developed to be used in the testbed. If you want to learn how to
            use the mouse joint, look at the testbed.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.#ctor(FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2)">
            <summary>
            This requires a world target point,
            tuning parameters, and the time step.
            </summary>
            <param name="body">The body.</param>
            <param name="worldAnchor">The target.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.MaxForce">
            <summary>
            The maximum constraint force that can be exerted
            to move the candidate body. Usually you will express
            as some multiple of the weight (multiplier * mass * gravity).
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.Frequency">
            <summary>
            The response speed.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint">
            <summary>
            A prismatic joint. This joint provides one degree of freedom: translation
            along an axis fixed in body1. Relative rotation is prevented. You can
            use a joint limit to restrict the range of motion and a joint motor to
            drive the motion or to model joint friction.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.#ctor(FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
            <param name="body">The body.</param>
            <param name="worldAnchor">The anchor.</param>
            <param name="axis">The axis.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.JointTranslation">
            <summary>
            Get the current joint translation, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.JointSpeed">
            <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.LowerLimit">
            <summary>
            Get the lower joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.UpperLimit">
            <summary>
            Get the upper joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorSpeed">
            <summary>
            Set the motor speed, usually in meters per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MaxMotorForce">
            <summary>
            Set the maximum motor force, usually in N.
            </summary>
            <value>The force.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorForce">
            <summary>
            Get the current motor force, usually in N.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint">
            <summary>
            A revolute joint rains to bodies to share a common point while they
            are free to rotate about the point. The relative rotation about the shared
            point is the joint angle. You can limit the relative rotation with
            a joint limit that specifies a lower and upper angle. You can use a motor
            to drive the relative rotation about the shared point. A maximum motor torque
            is provided so that infinite forces are not generated.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.#ctor(FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Initialize the bodies, anchors, and reference angle using the world
            anchor.
            This requires defining an
            anchor point where the bodies are joined. The definition
            uses local anchor points so that the initial configuration
            can violate the constraint slightly. You also need to
            specify the initial relative angle for joint limits. This
            helps when saving and loading a game.
            The local anchor points are measured from the body's origin
            rather than the center of mass because:
            1. you might not know where the center of mass will be.
            2. if you add/remove shapes from a body and recompute the mass,
            the joints will be broken.
            </summary>
            <param name="body">The body.</param>
            <param name="bodyAnchor">The body anchor.</param>
            <param name="worldAnchor">The world anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.JointAngle">
            <summary>
            Get the current joint angle in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.JointSpeed">
            <summary>
            Get the current joint angle speed in radians per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.LowerLimit">
            <summary>
            Get the lower joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.UpperLimit">
            <summary>
            Get the upper joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorSpeed">
            <summary>
            Set the motor speed in radians per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MaxMotorTorque">
            <summary>
            Set the maximum motor torque, usually in N-m.
            </summary>
            <value>The torque.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorTorque">
            <summary>
            Get the current motor torque, usually in N-m.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FrictionJoint">
            <summary>
            Friction joint. This is used for top-down friction.
            It provides 2D translational friction and angular friction.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FrictionJoint.MaxForce">
            <summary>
            The maximum friction force in N.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FrictionJoint.MaxTorque">
            <summary>
            The maximum friction torque in N-m.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.GearJoint">
            <summary>
            A gear joint is used to connect two joints together. Either joint
            can be a revolute or prismatic joint. You specify a gear ratio
            to bind the motions together:
            coordinate1 + ratio * coordinate2 = ant
            The ratio can be negative or positive. If one joint is a revolute joint
            and the other joint is a prismatic joint, then the ratio will have units
            of length or units of 1/length.
            @warning The revolute and prismatic joints must be attached to
            fixed bodies (which must be body1 on those joints).
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.GearJoint.#ctor(FarseerPhysics.Dynamics.Joints.Joint,FarseerPhysics.Dynamics.Joints.Joint,System.Single)">
            <summary>
            Requires two existing revolute or prismatic joints (any combination will work).
            The provided joints must attach a dynamic body to a static body.
            </summary>
            <param name="jointA">The first joint.</param>
            <param name="jointB">The second joint.</param>
            <param name="ratio">The ratio.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.Ratio">
            <summary>
            The gear ratio.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.JointA">
            <summary>
            The first revolute/prismatic joint attached to the gear joint.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.JointB">
            <summary>
            The second revolute/prismatic joint attached to the gear joint.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.JointEdge">
            <summary>
            A joint edge is used to connect bodies and joints together
            in a joint graph where each body is a node and each joint
            is an edge. A joint edge belongs to a doubly linked list
            maintained in each attached body. Each joint has two joint
            nodes, one for each attached body.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Joint">
            <summary>
            The joint.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Next">
            <summary>
            The next joint edge in the body's joint list.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Other">
            <summary>
            Provides quick access to the other body attached.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Prev">
            <summary>
            The previous joint edge in the body's joint list.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.Joint.Breakpoint">
            <summary>
            The Breakpoint simply indicates the maximum Value the JointError can be before it breaks.
            The default value is float.MaxValue
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.#ctor(FarseerPhysics.Dynamics.Body)">
            <summary>
            Constructor for fixed joint
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.JointType">
            <summary>
            Gets or sets the type of the joint.
            </summary>
            <value>The type of the joint.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.BodyA">
            <summary>
            Get the first body attached to this joint.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.BodyB">
            <summary>
            Get the second body attached to this joint.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.WorldAnchorA">
            <summary>
            Get the anchor point on body1 in world coordinates.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.WorldAnchorB">
            <summary>
            Get the anchor point on body2 in world coordinates.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.UserData">
            <summary>
            Set the user data pointer.
            </summary>
            <value>The data.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.Active">
            <summary>
            Short-cut function to determine if either body is inactive.
            </summary>
            <value><c>true</c> if active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.CollideConnected">
            <summary>
            Set this flag to true if the attached bodies should collide.
            </summary>
        </member>
        <member name="E:FarseerPhysics.Dynamics.Joints.Joint.Broke">
            <summary>
            Fires when the joint is broken.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.GetReactionForce(System.Single)">
            <summary>
            Get the reaction force on body2 at the joint anchor in Newtons.
            </summary>
            <param name="inv_dt">The inv_dt.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.GetReactionTorque(System.Single)">
            <summary>
            Get the reaction torque on body2 in N*m.
            </summary>
            <param name="inv_dt">The inv_dt.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.IsFixedType">
            <summary>
            Return true if the joint is a fixed type.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.SolvePositionConstraints">
            <summary>
            Solves the position constraints.
            </summary>
            <returns>returns true if the position errors are within tolerance.</returns>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.PrismaticJoint">
            <summary>
            A prismatic joint. This joint provides one degree of freedom: translation
            along an axis fixed in body1. Relative rotation is prevented. You can
            use a joint limit to restrict the range of motion and a joint motor to
            drive the motion or to model joint friction.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.PrismaticJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="localAnchorA">The first body anchor.</param>
            <param name="localAnchorB">The second body anchor.</param>
            <param name="axis">The axis.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.JointTranslation">
            <summary>
            Get the current joint translation, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.JointSpeed">
            <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.LowerLimit">
            <summary>
            Get the lower joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.UpperLimit">
            <summary>
            Get the upper joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorSpeed">
            <summary>
            Set the motor speed, usually in meters per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MaxMotorForce">
            <summary>
            Set the maximum motor force, usually in N.
            </summary>
            <value>The force.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorForce">
            <summary>
            Get the current motor force, usually in N.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.PulleyJoint">
            <summary>
            The pulley joint is connected to two bodies and two fixed ground points.
            The pulley supports a ratio such that:
            length1 + ratio * length2 <!--<-->= ant
            Yes, the force transmitted is scaled by the ratio.
            The pulley also enforces a maximum length limit on both sides. This is
            useful to prevent one side of the pulley hitting the top.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.PulleyJoint.GroundAnchorA">
            <summary>
            Get the first ground anchor.
            </summary>
            <value></value>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.PulleyJoint.GroundAnchorB">
            <summary>
            Get the second ground anchor.
            </summary>
            <value></value>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.PulleyJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Single)">
            <summary>
            Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
            This requires two ground anchors,
            two dynamic body anchor points, max lengths for each side,
            and a pulley ratio.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="groundAnchorA">The ground anchor for the first body.</param>
            <param name="groundAnchorB">The ground anchor for the second body.</param>
            <param name="localAnchorA">The first body anchor.</param>
            <param name="localAnchorB">The second body anchor.</param>
            <param name="ratio">The ratio.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.LengthA">
            <summary>
            Get the current length of the segment attached to body1.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.LengthB">
            <summary>
            Get the current length of the segment attached to body2.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.Ratio">
            <summary>
            Get the pulley ratio.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.RevoluteJoint">
            <summary>
            A revolute joint rains to bodies to share a common point while they
            are free to rotate about the point. The relative rotation about the shared
            point is the joint angle. You can limit the relative rotation with
            a joint limit that specifies a lower and upper angle. You can use a motor
            to drive the relative rotation about the shared point. A maximum motor torque
            is provided so that infinite forces are not generated.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.RevoluteJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Initialize the bodies and local anchor.
            This requires defining an
            anchor point where the bodies are joined. The definition
            uses local anchor points so that the initial configuration
            can violate the constraint slightly. You also need to
            specify the initial relative angle for joint limits. This
            helps when saving and loading a game.
            The local anchor points are measured from the body's origin
            rather than the center of mass because:
            1. you might not know where the center of mass will be.
            2. if you add/remove shapes from a body and recompute the mass,
            the joints will be broken.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="localAnchorA">The first body anchor.</param>
            <param name="localAnchorB">The second anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.JointAngle">
            <summary>
            Get the current joint angle in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.JointSpeed">
            <summary>
            Get the current joint angle speed in radians per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.LowerLimit">
            <summary>
            Get the lower joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.UpperLimit">
            <summary>
            Get the upper joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorSpeed">
            <summary>
            Set the motor speed in radians per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MaxMotorTorque">
            <summary>
            Set the maximum motor torque, usually in N-m.
            </summary>
            <value>The torque.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorTorque">
            <summary>
            Get the current motor torque, usually in N-m.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.RopeJoint">
            <summary>
            A rope joint enforces a maximum distance between two points
            on two bodies. It has no other effect.
            Warning: if you attempt to change the maximum length during
            the simulation you will get some non-physical behavior.
            A model that would allow you to dynamically modify the length
            would have some sponginess, so I chose not to implement it
            that way. See b2DistanceJoint if you want to dynamically
            control length.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RopeJoint.MaxLength">
            Get the maximum length of the rope.
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.SliderJoint">
            <summary>
            A distance joint contrains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.SliderJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.Joints.SliderJoint"/> class.
            Warning: Do not use a zero or short length.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="localAnchorA">The first body anchor.</param>
            <param name="localAnchorB">The second body anchor.</param>
            <param name="minLength">The minimum length between anchorpoints</param>
            <param name="maxlength">The maximum length between anchorpoints.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.MaxLength">
            <summary>
            The maximum length between the anchor points.
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.MinLength">
            <summary>
            The minimal length between the anchor points.
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.Frequency">
            <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
            <value>The frequency.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
            <value>The damping ratio.</value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.WeldJoint">
            <summary>
            A weld joint essentially glues two bodies together. A weld joint may
            distort somewhat because the island constraint solver is approximate.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.WeldJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            You need to specify a local anchor point
            where they are attached and the relative body angle. The position
            of the anchor point is important for computing the reaction torque.
            You can change the anchor points relative to bodyA or bodyB by changing LocalAnchorA
            and/or LocalAnchorB.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="localAnchorA">The first body anchor.</param>
            <param name="localAnchorB">The second body anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.WeldJoint.ReferenceAngle">
            <summary>
            The body2 angle minus body1 angle in the reference state (radians).
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.TimeStep">
            <summary>
            This is an internal structure.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.TimeStep.dt">
            <summary>
            Time step (Delta time)
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.TimeStep.dtRatio">
            <summary>
            dt * inv_dt0
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.TimeStep.inv_dt">
            <summary>
            Inverse time step (0 if dt == 0).
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.FilterData">
            <summary>
            Contains filter data that can determine whether an object should be processed or not.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.FilterData.AddDisabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Adds the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.FilterData.RemoveDisabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Removes the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.FilterData.IsInDisabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="category">The category.</param>
            <returns>
            	<c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.FilterData.AddEnabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Adds the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.FilterData.RemoveEnabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Removes the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.FilterData.IsInEnabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="category">The category.</param>
            <returns>
            	<c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="F:FarseerPhysics.Dynamics.WorldFlags.NewFixture">
            <summary>
            Flag that indicates a new fixture has been added to the world.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.WorldFlags.ClearForces">
            <summary>
            Flag that clear the forces after each time step.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.World">
            <summary>
            The world class manages all physics entities, dynamic simulation,
            and asynchronous queries.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.BodyAdded">
            <summary>
            Fires whenever a body has been added
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.BodyRemoved">
            <summary>
            Fires whenever a body has been removed
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.FixtureAdded">
            <summary>
            Fires whenever a fixture has been added
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.FixtureRemoved">
            <summary>
            Fires whenever a fixture has been removed
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.JointAdded">
            <summary>
            Fires whenever a joint has been added
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.JointRemoved">
            <summary>
            Fires whenever a joint has been removed
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.Enabled">
            <summary>
            If false, the whole simulation stops. It still processes added and removed geometries.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.World"/> class.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.#ctor(WaveEngine.Common.Math.Vector2)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.World"/> class.
            </summary>
            <param name="gravity">The gravity.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.ProxyCount">
            <summary>
            Get the number of broad-phase proxies.
            </summary>
            <value>The proxy count.</value>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.Gravity">
            <summary>
            Change the global gravity vector.
            </summary>
            <value>The gravity.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.AutoClearForces">
            <summary>
            Set flag to control automatic clearing of forces after each time step.
            </summary>
            <value><c>true</c> if it should auto clear forces; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.ContactManager">
            <summary>
            Get the contact manager for testing.
            </summary>
            <value>The contact manager.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.BodyList">
            <summary>
            Get the world body list.
            </summary>
            <value>Thehead of the world body list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.JointList">
            <summary>
            Get the world joint list. 
            </summary>
            <value>The joint list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.ContactList">
            <summary>
            Get the world contact list. With the returned contact, use Contact.GetNext to get
            the next contact in the world list. A null contact indicates the end of the list.
            </summary>
            <value>The head of the world contact list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.EnableSubStepping">
            <summary>
            Enable/disable single stepped continuous physics. For testing.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.AddBody(FarseerPhysics.Dynamics.Body)">
            <summary>
            Add a rigid body.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.RemoveBody(FarseerPhysics.Dynamics.Body)">
            <summary>
            Destroy a rigid body.
            Warning: This automatically deletes all associated shapes and joints.
            </summary>
            <param name="body">The body.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.AddJoint(FarseerPhysics.Dynamics.Joints.Joint)">
            <summary>
            Create a joint to constrain bodies together. This may cause the connected bodies to cease colliding.
            </summary>
            <param name="joint">The joint.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.RemoveJoint(FarseerPhysics.Dynamics.Joints.Joint)">
            <summary>
            Destroy a joint. This may cause the connected bodies to begin colliding.
            </summary>
            <param name="joint">The joint.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.ProcessChanges">
            <summary>
            All adds and removes are cached by the World duing a World step.
            To process the changes before the world updates again, call this method.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.Step(System.Single)">
            <summary>
            Take a time step. This performs collision detection, integration,
            and consraint solution.
            </summary>
            <param name="dt">The amount of time to simulate, this should not vary.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.ClearForces">
            <summary>
            Call this after you are done with time steps to clear the forces. You normally
            call this after each call to Step, unless you are performing sub-steps. By default,
            forces will be automatically cleared, so you don't need to call this function.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.QueryAABB(System.Func{FarseerPhysics.Dynamics.Fixture,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query the world for all fixtures that potentially overlap the
            provided AABB.
            
            Inside the callback:
            Return true: Continues the query
            Return false: Terminate the query
            </summary>
            <param name="callback">A user implemented callback class.</param>
            <param name="aabb">The aabb query box.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.RayCast(FarseerPhysics.Dynamics.RayCastCallback,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            Ray-cast the world for all fixtures in the path of the ray. Your callback
            controls whether you get the closest point, any point, or n-points.
            The ray-cast ignores shapes that contain the starting point.
            
            Inside the callback:
            return -1: ignore this fixture and continue
            return 0: terminate the ray cast
            return fraction: clip the ray to this point
            return 1: don't clip the ray and continue
            </summary>
            <param name="callback">A user implemented callback class.</param>
            <param name="point1">The ray starting point.</param>
            <param name="point2">The ray ending point.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.SolveTOI(FarseerPhysics.Dynamics.TimeStep@)">
            <summary>
            Find TOI contacts and solve them.
            </summary>
            <param name="step">The step.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.TestPointAll(WaveEngine.Common.Math.Vector2)">
            <summary>
            Returns a list of fixtures that are at the specified point.
            </summary>
            <param name="point">The point.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:FarseerPhysics.Dynamics.RayCastCallback">
            <summary>
            Called for each fixture found in the query. You control how the ray cast
            proceeds by returning a float:
            <returns>-1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue</returns>
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.EndContactDelegate">
            <summary>
            This delegate is called when a contact is deleted
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.BeginContactDelegate">
            <summary>
            This delegate is called when a contact is created
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.EnableDiagnostics">
            <summary>
            Enabling diagnistics causes the engine to gather timing information.
            You can see how much time it took to solve the contacts, solve CCD
            and update the controllers.
            NOTE: If you are using a debug view that shows performance counters,
            you might want to enable this.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.VelocityIterations">
            <summary>
            The number of velocity iterations used in the solver.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.PositionIterations">
            <summary>
            The number of position iterations used in the solver.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.ContinuousPhysics">
            <summary>
            Enable/Disable Continuous Collision Detection (CCD)
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.TOIVelocityIterations">
            <summary>
            The number of velocity iterations in the TOI solver
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.TOIPositionIterations">
            <summary>
            The number of position iterations in the TOI solver
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxSubSteps">
            <summary>
            Maximum number of sub-steps per contact in continuous physics simulation.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.EnableWarmstarting">
            <summary>
            Enable/Disable warmstarting
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.AllowSleep">
            <summary>
            Enable/Disable sleeping
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxPolygonVertices">
            <summary>
            The maximum number of vertices on a convex polygon.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.UseFPECollisionCategories">
            <summary>
            Farseer Physics Engine has a different way of filtering fixtures than Box2d.
            We have both FPE and Box2D filtering in the engine. If you are upgrading
            from earlier versions of FPE, set this to true.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.ConserveMemory">
            <summary>
            Conserve memory makes sure that objects are used by reference instead of cloned.
            When you give a vertices collection to a PolygonShape, it will by default copy the vertices
            instead of using the original reference. This is to ensure that objects modified outside the engine
            does not affect the engine itself, however, this uses extra memory. This behavior
            can be turned off by setting ConserveMemory to true.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxManifoldPoints">
            <summary>
            The maximum number of contact points between two convex shapes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.AABBExtension">
            <summary>
            This is used to fatten AABBs in the dynamic tree. This allows proxies
            to move by a small amount without triggering a tree adjustment.
            This is in meters.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.AABBMultiplier">
            <summary>
            This is used to fatten AABBs in the dynamic tree. This is used to predict
            the future position based on the current displacement.
            This is a dimensionless multiplier.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.LinearSlop">
            <summary>
            A small length used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.AngularSlop">
            <summary>
            A small angle used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.PolygonRadius">
            <summary>
            The radius of the polygon/edge shape skin. This should not be modified. Making
            this smaller means polygons will have an insufficient buffer for continuous collision.
            Making it larger may create artifacts for vertex collision.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxTOIContacts">
            <summary>
            Maximum number of contacts to be handled to solve a TOI impact.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.VelocityThreshold">
            <summary>
            A velocity threshold for elastic collisions. Any collision with a relative linear
            velocity below this threshold will be treated as inelastic.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxLinearCorrection">
            <summary>
            The maximum linear position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxAngularCorrection">
            <summary>
            The maximum angular position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.ContactBaumgarte">
            <summary>
            This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
            that overlap is removed in one time step. However using values close to 1 often lead
            to overshoot.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.TimeToSleep">
            <summary>
            The time that a body must be still before it will go to sleep.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.LinearSleepTolerance">
            <summary>
            A body cannot sleep if its linear velocity is above this tolerance.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.AngularSleepTolerance">
            <summary>
            A body cannot sleep if its angular velocity is above this tolerance.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxTranslation">
            <summary>
            The maximum linear velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Settings.MaxRotation">
            <summary>
            The maximum angular velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Settings.MixFriction(System.Single,System.Single)">
            <summary>
            Friction mixing law. Feel free to customize this.
            </summary>
            <param name="friction1">The friction1.</param>
            <param name="friction2">The friction2.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:FarseerPhysics.Settings.MixRestitution(System.Single,System.Single)">
            <summary>
            Restitution mixing law. Feel free to customize this.
            </summary>
            <param name="restitution1">The restitution1.</param>
            <param name="restitution2">The restitution2.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:QuadTree`1.Partition(FarseerPhysics.Collision.AABB,FarseerPhysics.Collision.AABB)">
            <summary>
            returns the quadrant of span that entirely contains test. if none, return 0.
            </summary>
            <param name="span"></param>
            <param name="test"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:QuadTree`1.RayCastAABB(FarseerPhysics.Collision.AABB,WaveEngine.Common.Math.Vector2,WaveEngine.Common.Math.Vector2)">
            <summary>
            tests if ray intersects AABB
            </summary>
            <param name="aabb"></param>
            <returns>The result.</returns>
        </member>
        <member name="M:QuadTreeBroadPhase.#ctor(FarseerPhysics.Collision.AABB)">
            <summary>
            Creates a new quad tree broadphase with the specified span.
            </summary>
            <param name="span">the maximum span of the tree (world size)</param>
        </member>
        <member name="P:QuadTreeBroadPhase.ProxyCount">
            <summary>
             The number of proxies
            </summary>
        </member>
        <member name="M:QuadTreeBroadPhase.TestOverlap(System.Int32,System.Int32)">
            <summary>
            Test overlap of fat AABBs.
            </summary>
            <param name="proxyIdA">The proxy id A.</param>
            <param name="proxyIdB">The proxy id B.</param>
            <returns>The result.</returns>
        </member>
        <member name="F:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.EdgeIsConstrained">
            Neighbor pointers 
            Flags to determine if an edge is a Delauney edge 
        </member>
        <member name="F:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.EdgeIsDelaunay">
            Flags to determine if an edge is a Constrained edge 
        </member>
        <member name="F:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.Points">
            Has this triangle been marked as an interior triangle? 
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkNeighbor(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
            <summary>
            Update neighbor pointers
            </summary>
            <param name="p1">Point 1 of the shared edge</param>
            <param name="p2">Point 2 of the shared edge</param>
            <param name="t">This triangle's new neighbor</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkNeighbor(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
            <summary>
            Exhaustive search to update neighbor pointers
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.Clear">
            Clears all references to all other triangles and points
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.OppositePoint(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint)">
            <param name="t">Opposite triangle</param>
            <param name="p">The point in t that isn't shared between the triangles</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.Legalize(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            Legalize triangle by rotating clockwise around oPoint
            </summary>
            <param name="oPoint">The origin point to rotate around</param>
            <param name="nPoint">???</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkNeighborEdges">
            <summary>
            Finalize edge marking
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkConstrainedEdge(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            Mark edge as constrained
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.EdgeIndex(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            Get the index of the neighbor that shares this edge (or -1 if it isn't shared)
            </summary>
            <returns>index of the shared edge or -1 if edge isn't shared</returns>
        </member>
        <member name="T:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront">
            @author Thomas Åhlen (thahlen@gmail.com)
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront.FindSearchNode(System.Double)">
            <summary>
            MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of AdvancingFrontNodes near x
                 Removed an overload that depended on this being exact
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront.LocateNode(Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            We use a balancing tree to locate a node smaller or equal to given key value
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront.LocatePoint(Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            This implementation will use simple node traversal algorithm to find a point on the front
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Triangulate(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext)">
            <summary>
            Triangulate simple polygon with holes
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Sweep(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext)">
            <summary>
            Start sweeping the Y-sorted point set from bottom to top
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FinalizationConvexHull(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext)">
            <summary>
            If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull 
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.TurnAdvancingFrontConvex(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            We will traverse the entire advancing front and fill it to form a convex hull.
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PointEvent(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            Find closes node to the left of the new point and
            create a new triangle. If needed new holes and basins
            will be filled to.
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NewFrontTriangle(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Creates a new front triangle and legalize it
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipPoint(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            When we need to traverse from one triangle to the next we need 
            the point in current triangle that is the opposite point to the next
            triangle. 
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipTriangle(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Orientation,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            After a flip we have two triangles and know that only one will still be
            intersecting the edge. So decide which to contiune with and legalize the other
            </summary>
            <param name="tcx"></param>
            <param name="o">should be the result of an TriangulationUtil.orient2d( eq, op, ep )</param>
            <param name="t">triangle 1</param>
            <param name="ot">triangle 2</param>
            <param name="p">a point shared by both triangles</param>
            <param name="op">another point shared by both triangles</param>
            <returns>returns the triangle still intersecting the edge</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint)" -->
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillAdvancingFront(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Fills holes in the Advancing Front
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasin(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)" -->
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasinReq(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Recursive algorithm to fill a Basin with triangles
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.HoleAngle(Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            ???
            </summary>
            <param name="node">middle node</param>
            <returns>the angle between 3 front nodes</returns>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.BasinAngle(Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            The basin angle is decided against the horizontal line [1,0]
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Adds a triangle to the advancing front to fill a hole.
            </summary>
            <param name="tcx"></param>
            <param name="node">middle node, that is the bottom of the hole</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
            <summary>
            Returns true if triangle was legalized
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            Rotates a triangle pair one vertex CW
                  n2                    n2
             P +-----+             P +-----+
               | t  /|               |\  t |  
               |   / |               | \   |
             n1|  /  |n3           n1|  \  |n3
               | /   |    after CW   |   \ |
               |/ oT |               | oT \|
               +-----+ oP            +-----+
                  n4                    n4
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint.#ctor(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
            Give two points in any order. Will always be ordered so
            that q.y > p.y and q.x > p.x if same y value 
            </summary>
        </member>
        <member name="T:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext">
             
             @author Thomas Åhlén, thahlen@gmail.com
            
        </member>
        <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.MapTriangleToNodes(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
            <summary>
            Try to map a node to all sides of this triangle that don't have 
            a neighbor.
            </summary>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.#ctor(System.Collections.Generic.IList{Poly2Tri.Triangulation.Polygon.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.#ctor(System.Collections.Generic.IEnumerable{Poly2Tri.Triangulation.Polygon.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points.</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.PrepareTriangulation(Poly2Tri.Triangulation.TriangulationContext)">
            <summary>
            Creates constraints and populates the context with points
            </summary>
            <param name="tcx">The context</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.AddHole(Poly2Tri.Triangulation.Polygon.Polygon)">
            <summary>
            Add a hole to the polygon.
            </summary>
            <param name="poly">A subtraction polygon fully contained inside this polygon.</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.InsertPointAfter(Poly2Tri.Triangulation.Polygon.PolygonPoint,Poly2Tri.Triangulation.Polygon.PolygonPoint)">
            <summary>
            Inserts newPoint after point.
            </summary>
            <param name="point">The point to insert after in the polygon</param>
            <param name="newPoint">The point to insert into the polygon</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.AddPoints(System.Collections.Generic.IEnumerable{Poly2Tri.Triangulation.Polygon.PolygonPoint})">
            <summary>
            Inserts list (after last point in polygon?)
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.AddPoint(Poly2Tri.Triangulation.Polygon.PolygonPoint)">
            <summary>
            Adds a point after the last in the polygon.
            </summary>
            <param name="p">The point to add</param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.RemovePoint(Poly2Tri.Triangulation.Polygon.PolygonPoint)">
            <summary>
            Removes a point from the polygon.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:Poly2Tri.Triangulation.Sets.ConstrainedPointSet.#ctor(System.Collections.Generic.List{Poly2Tri.Triangulation.TriangulationPoint},System.Collections.Generic.IEnumerable{Poly2Tri.Triangulation.TriangulationPoint})">
            
            @param points - A list of all points in PointSet
            @param constraints - Pairs of two points defining a constraint, all points <b>must</b> be part of given PointSet!
        </member>
        <!-- Badly formed XML comment ignored for member "M:Poly2Tri.Triangulation.Sets.ConstrainedPointSet.isValid" -->
        <member name="T:Poly2Tri.Triangulation.TriangulationUtil">
            @author Thomas Åhlén, thahlen@gmail.com
        </member>
        <member name="M:Poly2Tri.Triangulation.TriangulationUtil.SmartIncircle(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            <summary>
              Requirements:
            1. a,b and c form a triangle.
            2. a and d is know to be on opposite side of bc
            <code>
                           a
                           +
                          / \
                         /   \
                       b/     \c
                       +-------+ 
                      /    B    \  
                     /           \ 
            </code>
               Facts:
             d has to be in area B to have a chance to be inside the circle formed by a,b and c
             d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
             This preknowledge gives us a way to optimize the incircle test
            </summary>
            <param name="pa">triangle point, opposite d</param>
            <param name="pb">triangle point</param>
            <param name="pc">triangle point</param>
            <param name="pd">point opposite a</param>
            <returns>true if d is inside circle, false if on circle edge</returns>
        </member>
        <member name="M:Poly2Tri.Triangulation.TriangulationUtil.Orient2d(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            Forumla to calculate signed area
            Positive if CCW
            Negative if CW
            0 if collinear
            A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
                         =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
        </member>
    </members>
</doc>
